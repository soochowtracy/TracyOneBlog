<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[TracyOne]]></title>
  <subtitle><![CDATA[iOS Rookie]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.tracyone.com//"/>
  <updated>2015-06-10T13:33:29.000Z</updated>
  <id>http://blog.tracyone.com//</id>
  
  <author>
    <name><![CDATA[Tracy Wang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Think in Block(下)]]></title>
    <link href="http://blog.tracyone.com/2015/06/10/Think-in-Block-%E4%B8%8B/"/>
    <id>http://blog.tracyone.com/2015/06/10/Think-in-Block-下/</id>
    <published>2015-06-10T13:28:22.000Z</published>
    <updated>2015-06-10T13:33:29.000Z</updated>
    <content type="html"><![CDATA[<p>这一篇主要浅析下Block和Objc的关系，更加偏向于实际应用。其实大多数时间我们是和Objc对象打交道，知道一点原理，能避免死的不明不白。</p>
<p>在这个过程中也会回答前面留下的坑- -，探究下来感觉，纸上得来终觉浅，以前也看过这本书，但是一直没有动手敲代码，浮于表面了。</p>
<h3 id="截获Objc对象">截获Objc对象</h3><p>先看下源程序，声明了一个Block对象，这次用到了copy，然后最后调用了三次，输出的结果是1，2，3。这一次转换后的代码非常多，不过抽离出来后也很简洁。</p>
<a id="more"></a>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)(<span class="keyword">id</span> obj);
<span class="keyword">int</span> main(){

    blk_t blk;
    {
        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];

        blk = [^(<span class="keyword">id</span> obj){
            [array addObject:obj];

            <span class="built_in">NSLog</span>(<span class="string">@"array count = %ld"</span>, [array count]);
        } <span class="keyword">copy</span>];
    }

    blk([[<span class="built_in">NSObject</span> alloc] init]);
    blk([[<span class="built_in">NSObject</span> alloc] init]);
    blk([[<span class="built_in">NSObject</span> alloc] init]);
}
</code></pre><p>在这里，我们能够看出来，Block对于Objc对象的截获是通过指针，并且和外部修饰符一致，也就是说外部是strong，内部也是strong，然后c结构体中并不能很好地管理内存，所以其实是通过运行时来掌控的，也就是后面会看到的copy和dispose函数的作用。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(*blk_t)(<span class="keyword">id</span> obj);
<span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  <span class="keyword">id</span> array;
  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">id</span> _array, <span class="keyword">int</span> flags=<span class="number">0</span>) : array(_array) {
    impl<span class="variable">.isa</span> = &amp;_<span class="built_in">NSConcreteStackBlock</span>;
    impl<span class="variable">.Flags</span> = flags;
    impl<span class="variable">.FuncPtr</span> = fp;
    Desc = desc;
  }
};

<span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself, <span class="keyword">id</span> obj) {
      <span class="keyword">id</span> array = __cself-&gt;array; <span class="comment">// bound by copy</span>

      ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)array, sel_registerName(<span class="string">"addObject:"</span>), (<span class="keyword">id</span>)obj);

      <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__<span class="built_in">NSConstantStringImpl__var_folders_hv_3dth3by12sg3t1g37hq5plkw0000gn_T_main_18c6fa_mi_0</span>, ((<span class="built_in">NSUInteger</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)array, sel_registerName(<span class="string">"count"</span>)));
}
</code></pre><ol>
<li>在把Block对象拷贝到堆上的时候copy函数会被调用，而在Block从堆上释放的时候dispose会被调用。</li>
<li>在调用copy函数的时候_Block_object_assign将外部对象赋值给Block结构体的成员变量，并持有它。</li>
<li>在调用dispose函数的时候_Block_object_dispose将释放Block结构体的成员变量。</li>
</ol>
<p>有了这些隐藏在背后的操作后，通过使用strong类型的局部对象，Block截获后能够在超出其变量作用域而存在。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) {
    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="built_in">array</span>, (<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);
}

<span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) {
    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);
}

<span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 {
  <span class="keyword">size_t</span> reserved;
  <span class="keyword">size_t</span> Block_size;
  <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);
  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);
} __main_block_desc_0_DATA = { <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
</code></pre><p>其实回过头去看一下截获__block变量的时候也生成了两个类似的函数，唯一的区别是BLOCK_FIELD_IS_OBJECT和BLOCK_FIELD_IS_BYREF，这只是用来标示这是一个对象，还是一个变量。</p>
<pre><code>int main<span class="params">()</span>{

    blk_t blk;
    {
        id array = <span class="params">(<span class="params">(NSMutableArray *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(NSMutableArray *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSMutableArray"</span>)</span>, sel_registerName<span class="params">(<span class="string">"alloc"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"init"</span>)</span>)</span>;

        blk = <span class="params">(blk_t)</span><span class="params">(<span class="params">(id <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>&amp;__main_block_impl_0<span class="params">(<span class="params">(void *)</span>__main_block_func_0, &amp;__main_block_desc_0_DATA, array, <span class="number">570425344</span>)</span>, sel_registerName<span class="params">(<span class="string">"copy"</span>)</span>)</span>;
    }


    <span class="params">(<span class="params">(void <span class="params">(*)</span><span class="params">(__block_impl *, id)</span>)</span><span class="params">(<span class="params">(__block_impl *)</span>blk)</span>-&gt;FuncPtr)</span><span class="params">(<span class="params">(__block_impl *)</span>blk, <span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"alloc"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"init"</span>)</span>)</span>)</span>;
    <span class="params">(<span class="params">(void <span class="params">(*)</span><span class="params">(__block_impl *, id)</span>)</span><span class="params">(<span class="params">(__block_impl *)</span>blk)</span>-&gt;FuncPtr)</span><span class="params">(<span class="params">(__block_impl *)</span>blk, <span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"alloc"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"init"</span>)</span>)</span>)</span>;
    <span class="params">(<span class="params">(void <span class="params">(*)</span><span class="params">(__block_impl *, id)</span>)</span><span class="params">(<span class="params">(__block_impl *)</span>blk)</span>-&gt;FuncPtr)</span><span class="params">(<span class="params">(__block_impl *)</span>blk, <span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"alloc"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"init"</span>)</span>)</span>)</span>;

}
</code></pre><p>tips：上面这些代码其实和书上的有一定的区别，也即是前面说得，我们的技术在提升，当然苹果没有理由不提升，不管是编译器还是底层实现。其实这里加不加copy都一样，应该是最近ARC的机制有了一点改变，这个后面会出一篇Blog详解。</p>
<h3 id="循环引用">循环引用</h3><p>由于上边所示那样的内存管理机制，当我们截获strong类型的对象时，很容易出现循环引用，但是也不用担心，没必要无时不刻的用一个__weak来避免，盲目地使用只会暴露出并没有深入地理解。</p>
<p>这里给出三种方法来避免循环引用：</p>
<ol>
<li>__weak 修饰符</li>
</ol>
<p>通过weak肯定能解除循环引用，但也有缺点，有时候我们会在内部使用strong来保证执行block的时候外部变量不会释放，但这也不能避免在block执行前已经释放了这种情形。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)();
<span class="class"><span class="keyword">@interface</span> <span class="title">Block</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)blk_t blk;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">Block</span></span>
- (instancetype)init{
    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {
        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;
        <span class="keyword">self</span><span class="variable">.blk</span> = ^{
            <span class="built_in">NSLog</span>(<span class="string">@"test%@"</span>, weakSelf<span class="variable">.array</span>);
        };
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
<span class="keyword">@end</span>
</code></pre><ol>
<li>__block修饰符+nil操作</li>
</ol>
<p>这种情况则也能避免循环引用，但是有个前提，这个Block必须在某个地方执行，否则还是不能打破循环引用环，但是这么做的好处还是很多的，首先可以延长生命周期，其次在执行Block的时候可以决定是否是将nil赋予，还是给另一个值。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)();
<span class="class"><span class="keyword">@interface</span> <span class="title">Block</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)blk_t blk;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">Block</span></span>
- (instancetype)init{
    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {

        __block <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;

        <span class="keyword">self</span><span class="variable">.blk</span> = ^{
            <span class="built_in">NSLog</span>(<span class="string">@"test%@"</span>, weakSelf<span class="variable">.array</span>);
            weakSelf = <span class="literal">nil</span>;
        };
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
<span class="keyword">@end</span>
</code></pre><ol>
<li><strong>unsafe</strong>unretain修饰符</li>
</ol>
<p>这其实只是用在一些weak不支持的场合，现在几乎不怎么用了。</p>
<p>三者各有优缺点，<strong>weak不能够延长生命周期，</strong>block修饰符，如果最后没有执行，导致赋值nil不能够执行则还是会循环引用，<strong>unsafe</strong>unretain和weak相似，但是有可能会出现野指针的情况。</p>
<h3 id="MRC下地Block">MRC下地Block</h3><ul>
<li>在mrc下需要手动的调用copy和release，只要是copy到堆上了，则可以使用retain来持有，否则retain并没有效果。</li>
<li>在C语言中也支持，使用的是Block_copy和Block_release函数。</li>
<li>在ARC无效的时候我们只需要使用<strong>block就能避免循环引用了，这是因为，在mrc下</strong>block对象不会被retain。</li>
</ul>
<h3 id="结束语">结束语</h3><p>关于Block的探究也差不多了，接下来就是实战中去体会了，不过在探究的过程中发现，是时候去深入地理解一下Objc的内存管理机制，同时也发现在这本书中的ARC讲解已经有点过时了，有些和真实地情况有出入。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一篇主要浅析下Block和Objc的关系，更加偏向于实际应用。其实大多数时间我们是和Objc对象打交道，知道一点原理，能避免死的不明不白。</p>
<p>在这个过程中也会回答前面留下的坑- -，探究下来感觉，纸上得来终觉浅，以前也看过这本书，但是一直没有动手敲代码，浮于表面了。</p>
<h3 id="截获Objc对象">截获Objc对象</h3><p>先看下源程序，声明了一个Block对象，这次用到了copy，然后最后调用了三次，输出的结果是1，2，3。这一次转换后的代码非常多，不过抽离出来后也很简洁。</p>]]>
    
    </summary>
    
      <category term="block" scheme="http://blog.tracyone.com/tags/block/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Think in Block(上)]]></title>
    <link href="http://blog.tracyone.com/2015/06/07/Think-in-Block-%E4%B8%8A/"/>
    <id>http://blog.tracyone.com/2015/06/07/Think-in-Block-上/</id>
    <published>2015-06-07T13:14:38.000Z</published>
    <updated>2015-06-09T13:22:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Block_简介">Block 简介</h2><p>这不是一篇介绍如何使用Block的文章，主要想要探究一下系统背后Block发生了什么，主要参考的是《Objective-C高级编程》这本书，不过这本书本身也有些年代了，苹果实现的机制也有了一些改变。实践出真知，不清楚的地方自己动手试一下，会有意外地收获。</p>
<h3 id="Block是什么">Block是什么</h3><p>苹果官网说法：<br>A block is an anonymous inline collection of code, and sometimes also called a “closure”.</p>
<p>通俗的讲：<br>闭包就是能够读取其它函数内部变量的匿名函数</p>
<p>与普通函数的区别：<br>普通函数能使用局部变量，参数，静态变量，静态全局，全局变量，并且有自己的函数名。<br>block除了能使用这些外还能使用其他函数内的变量，而且没有函数名。</p>
<a id="more"></a>
<h3 id="BLock的用法和功能">BLock的用法和功能</h3><h5 id="语法">语法</h5><p>void (^)(void){<br>};<br>与C语言函数相比没有函数名，带有^；可省略很多部分。</p>
<h5 id="变量">变量</h5><p>void (^var)(void)；<br>与C语言函数指针相比只是把*改成了^,Block变量和普通变量作用完全相同。</p>
<ol>
<li>通过typedef可以简化声明</li>
<li>调用和C语言函数调用一样，变量名+小括号</li>
</ol>
<h5 id="截获变量">截获变量</h5><ol>
<li>Block可以使用在它之前声明的局部变量，因此在执行Block时，即使已经改变了值，也不影响Block中截获的值。</li>
<li>一般情况，Block只能保存声明时的瞬间值，保存后就不能修改了；如果需要改变则要附加__block.</li>
<li>如果截获的是oc对象，使用是没有问题的，但是如果要重新赋值，则也必须加__block。</li>
</ol>
<h3 id="Block的实现">Block的实现</h3><h5 id="Block的本质">Block的本质</h5><p>先看下源代码：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{

    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
        <span class="built_in">printf</span>(<span class="string">"Block\n"</span>);
    };

    blk();
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>很简单，简单地定义一个Block，赋给blk对象，然后调用这个Block，那么这段代码经过编译器编译过后，发生了什么呢？我们用Clang 命令 -rewirte-objc转换成c++看下编译器搞得什么鬼！</p>
<p>首先是这一段，这段代码是编译器插入的代码，主要作用就是声明了一个结构体，这可以看成是我们的<code>Block类</code>的数据部分</p>
<pre><code><span class="preprocessor">#ifndef BLOCK_IMPL</span>
<span class="preprocessor">#define BLOCK_IMPL</span>
<span class="keyword">struct</span> __block_impl {
  <span class="keyword">void</span> *isa;
  <span class="keyword">int</span> Flags;
  <span class="keyword">int</span> Reserved;
  <span class="keyword">void</span> *FuncPtr;
};
</code></pre><p>这一段则是系统给我们声明的真正的<code>Block类</code>，其中包括了数据部分和一些描述性内容，以及一个初始化函数。</p>
<pre><code><span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl <span class="keyword">impl</span>;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) {
    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;
    <span class="keyword">impl</span>.Flags = flags;
    <span class="keyword">impl</span>.FuncPtr = fp;
    Desc = desc;
  }
};
</code></pre><p>这一段则是赋值给Block变量中的那个函数的声明，其中会把self传入，这个很多语言都会这么处理，在内部使用self的时候能够找到真实地那个对象。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) {

        <span class="built_in">printf</span>(<span class="string">"Block\n"</span>);
    }
</code></pre><p>这一段则是前面所说的描述性的内容，主要就是Block对象的大小，因为这个例子比较简单，复杂的情况这里还会生成其他的一些函数，后面会讲到。<br>    static struct <strong>main_block_desc_0 {<br>      size_t reserved;<br>      size_t Block_size;<br>    } </strong>main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};</p>
<p>最后则是这一段我们写得main函数的代码，通过调用__main_block_impl_0函数来初始化一个Block对象，最后调用也就是简单地用c语言函数指针的方式调用。<br>    int main() {</p>
<pre><code>    void <span class="comment">(*blk)(void) = (void (*)</span>())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);

    ((void <span class="comment">(*)(__block_impl *)</span>)((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
    return <span class="number">0</span>;
}
</code></pre><p>从isa的存在我们也大概能够看出来Block其实就是Objc的对象，只不过这是一个为了性能考虑而可能在栈上生成的一个对象。</p>
<h5 id="如何截获自动变量">如何截获自动变量</h5><p>这一次尝试一下使用Block来截获外部变量，看一下，Block如何能够使用外部变量，原函数：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span>{

    <span class="keyword">int</span> dmy = <span class="number">256</span>;
    <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">10</span>;
    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"var = %d\n"</span>;

    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
        printf(fmt, <span class="keyword">var</span>);
    };

    <span class="keyword">var</span> = <span class="number">2</span>;
    fmt = <span class="string">"Real var = %d\n"</span>;

    blk();
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>重写以后发现，其实没有多大改变，只是多了一些内容：</p>
<ul>
<li>__main_block_impl_0中多了一个指针fmt，和int类型的变量，其实也很容易理解，就是用来存放外部变量的。</li>
<li>__main_block_impl_0初始化的时候会同时对成员变量赋值。</li>
<li>__main_block_func_0中会在开始的地方帮你声明两个同名的变量，赋值的值则是从传入的self通过指针取值。</li>
</ul>
<p>那么其实从这些我们也不难看出，Block其实只截获了内部用到对象，以及为什么Block中普通截获的值不能改变，当然不能改写只是编译器检查，因为改了也没用。</p>
<pre><code><span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;
  <span class="keyword">int</span> <span class="keyword">var</span>;
  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _var, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), <span class="keyword">var</span>(_var) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
<span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) {
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// bound by copy</span>
  <span class="keyword">int</span> <span class="keyword">var</span> = __cself-&gt;<span class="keyword">var</span>; <span class="comment">// bound by copy</span>

        printf(fmt, <span class="keyword">var</span>);
    }

<span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)};
<span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span>{

    <span class="keyword">int</span> dmy = <span class="number">256</span>;
    <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">10</span>;
    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"var = %d\n"</span>;

    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, <span class="keyword">var</span>);

    <span class="keyword">var</span> = <span class="number">2</span>;
    fmt = <span class="string">"Real var = %d\n"</span>;

    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><h3 id="__block的作用">__block的作用</h3><p>首先来看下，有哪些变量是就算不在函数内声明，函数中也能使用和改变值的：静态变量，静态全局，全局变量。那这些变量是通过什么方式来实现的呢？<br>对于全部变量来说，其实本身它的作用域就已经包括了函数所在区域，能使用并不奇怪，普通的静态变量其实是通过指针来做到的。<br>那其实也不难推出，__block基本上来说也是通过指针（因为这也是最简单地一种方法）。<br>废话不多说，上代码：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span>{

    __block <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">10</span>;
    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
        <span class="keyword">var</span> = <span class="number">1</span>;
    };
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>经过重写后发现，增加了狂多代码，不过不用慌，都是可读性很强的代码，慢慢分析。</p>
<p>这一段就是<strong>block说明符修饰过后的变量最终声明的结构体，其中 </strong>forwarding很重要（这个是不同存储区域能访问到同一个变量的关键）</p>
<pre><code><span class="keyword">struct</span> __Block_byref_var_0 {
  <span class="keyword">void</span> *__isa;
__Block_byref_var_0 *__forwarding;
 <span class="keyword">int</span> __flags;
 <span class="keyword">int</span> __size;
 <span class="keyword">int</span> <span class="keyword">var</span>;
};
</code></pre><p>在这里大概也看出了一点端倪，其实传给var指针的是_var-&gt;<strong>forwarding，后面会给出 </strong>forwarding指向的是谁。</p>
<pre><code>struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* <span class="type">Desc</span>;
  __Block_byref_var_0 *<span class="keyword">var</span>; // by <span class="keyword">ref</span>
  __main_block_impl_0(<span class="type">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_var_0 *_var, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="keyword">var</span>(_var-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.<span class="type">Flags</span> = flags;
    impl.<span class="type">FuncPtr</span> = fp;
    <span class="type">Desc</span> = desc;
  }
};
</code></pre><p>看到这，基本就知道为什么用__block修饰的变量，在Block中也能改变了，因为内部声明时是用了指针嘛。</p>
<pre><code><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_var_0 *<span class="keyword">var</span> = __cself-&gt;<span class="keyword">var</span>; // bound by <span class="keyword">ref</span>

        (<span class="keyword">var</span>-&gt;__forwarding-&gt;<span class="keyword">var</span>) = <span class="number">1</span>;
    }
</code></pre><p>这里的copy，和dispose先略过，在后续的Objc对象那部分会详解。<br>    static void <strong>main_block_copy_0(struct </strong>main_block_impl_0<em>dst, struct __main_block_impl_0</em>src) {_Block_object_assign((void<em>)&amp;dst-&gt;var, (void</em>)src-&gt;var, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);}</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) {_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;var, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);}

<span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 {
  <span class="keyword">size_t</span> reserved;
  <span class="keyword">size_t</span> Block_size;
  <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);
  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);
} __main_block_desc_0_DATA = { <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
</code></pre><p>通过这一段，可以看出其实var已经不是简单地Int类型了，变得老长老长了，编译器总是在默默中给我们加了点料。同时也知道了__forwarding指向的是var自身。<br>    int main() {</p>
<pre><code>    __attribute__<span class="params">(<span class="params">(__blocks__<span class="params">(byref)</span>)</span>)</span> __Block_byref_var_0 var = {<span class="params">(void*)</span><span class="number">0</span>,<span class="params">(__Block_byref_var_0 *)</span>&amp;var, <span class="number">0</span>, sizeof<span class="params">(__Block_byref_var_0)</span>, <span class="number">10</span>};
    void <span class="params">(*blk)</span><span class="params">(void)</span> = <span class="params">(void <span class="params">(*)</span><span class="params">()</span>)</span>&amp;__main_block_impl_0<span class="params">(<span class="params">(void *)</span>__main_block_func_0, &amp;__main_block_desc_0_DATA, <span class="params">(__Block_byref_var_0 *)</span>&amp;var, <span class="number">570425344</span>)</span>;
    return <span class="number">0</span>;
}
</code></pre><h3 id="Block,__block存储域">Block,__block存储域</h3><p>Q:Block超出变量作用域可存在？</p>
<p>A:</p>
<ol>
<li>配置在全局变量中得Block，在变量作用域之外也可以通过指针安全的使用</li>
<li>在栈上得Block则是通过复制到堆上来解决的</li>
<li>而<strong>block变量用 </strong>forward可以实现无论配置在哪都可以正确地访问 __block变量</li>
<li>在ARC下，大多数情况下编译器会恰当的判断，自动将Block从栈上复制到堆上。（autorelease）</li>
</ol>
<p>补充：</p>
<ul>
<li>自动copy：Block作为函数的返回值时</li>
<li>手动copy：向方法或函数的参数中传递Block（但是可以在函数中适当地copy就不必在传递前copy）（例如GCD，Animation等）</li>
</ul>
<p>Q:调用Copy时不同的Block对象究竟发生了什么：</p>
<ol>
<li>_NSConcreteStackBlock            ：从栈复制到堆</li>
<li>_NSConcreteGlobalBlock            ：什么也不做</li>
<li>_NSConcreteMallocBlock            ：引用计数增加</li>
</ol>
<p>Q:调用Copy时不同的__block对象究竟发生了什么：</p>
<ol>
<li>栈            ：从栈复制到堆，并且被Block持有</li>
<li>堆            ：被Block持有</li>
</ol>
<h3 id="新的开始">新的开始</h3><p>这一篇，主要把Block变量和__block变量分析了一下，对于Objc中得对象，Block如何处理放到下一篇详细的讲述，同时下一篇也会详细的讲解一下避免Block循环引用的N种姿势。以及之前没有讲得copy和dispose是干嘛的，顺带着还会说一下mrc下地Block。</p>
<p>当然本人才疏学浅，上面只是个人的一些理解，可能会有偏差，如果有误，欢迎吐槽纠正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Block_简介">Block 简介</h2><p>这不是一篇介绍如何使用Block的文章，主要想要探究一下系统背后Block发生了什么，主要参考的是《Objective-C高级编程》这本书，不过这本书本身也有些年代了，苹果实现的机制也有了一些改变。实践出真知，不清楚的地方自己动手试一下，会有意外地收获。</p>
<h3 id="Block是什么">Block是什么</h3><p>苹果官网说法：<br>A block is an anonymous inline collection of code, and sometimes also called a “closure”.</p>
<p>通俗的讲：<br>闭包就是能够读取其它函数内部变量的匿名函数</p>
<p>与普通函数的区别：<br>普通函数能使用局部变量，参数，静态变量，静态全局，全局变量，并且有自己的函数名。<br>block除了能使用这些外还能使用其他函数内的变量，而且没有函数名。</p>]]>
    
    </summary>
    
      <category term="block" scheme="http://blog.tracyone.com/tags/block/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
</feed>