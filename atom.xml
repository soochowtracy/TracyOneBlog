<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[TracyOne]]></title>
  <subtitle><![CDATA[iOS Rookie]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.tracyone.com//"/>
  <updated>2015-07-09T12:21:21.000Z</updated>
  <id>http://blog.tracyone.com//</id>
  
  <author>
    <name><![CDATA[Tracy Wang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Effective Obj-C <一>]]></title>
    <link href="http://blog.tracyone.com/2015/07/08/Effective-Obj-C-%E4%B8%80/"/>
    <id>http://blog.tracyone.com/2015/07/08/Effective-Obj-C-一/</id>
    <published>2015-07-08T12:31:36.000Z</published>
    <updated>2015-07-09T12:21:21.000Z</updated>
    <content type="html"><![CDATA[<p>其实很久以前就看过这本书了，在实践的过程中也不断的遵循着这些tips，不过随着时间的推移，苹果又加入了一些新元素，所以记录下来，不断的更新，完善这些iOS开发中需要注意的点。</p>
<h3 id="熟悉的Obj-C">熟悉的Obj-C</h3><p>这是一门很古老的语言了，古老到苹果已经推出新的语言来代替了，然而这也不能阻止我依然喜欢这门语言，虽然它还有很多缺陷，但也能看出苹果在不断的完善中。</p>
<a id="more"></a>
<h4 id="了解Obj-C的起源">了解Obj-C的起源</h4><p>和普通面向对象语言最大的区别是，消息发送和函数调用的区别，前者依托于运行时环境，而后者在编译期已经确定。</p>
<h4 id="类的头文件越简洁越好">类的头文件越简洁越好</h4><p>可以使用@class来取代import，然后在真正需要的地方使用import，还可以使用@import来引入模块，减少编译时间和引用泛滥。</p>
<p>协议尽量单独文件以减少不必要的引入，如果是类似于delegate的协议则可以放在同一个头文件，如果是实现这类协议可以放到类扩展中。</p>
<h4 id="便捷的字面量">便捷的字面量</h4><p>字面量能够极大的简化，而且可读性还增加了。</p>
<pre><code>NSNumber <span class="keyword">*</span>intNumber = <span class="comment">@1;</span>
NSNumber <span class="keyword">*</span>floatNumber = <span class="comment">@1.1;</span>
NSNumber <span class="keyword">*</span>boolNumber = <span class="comment">@YES;</span>
NSNumber <span class="keyword">*</span>charNumber = <span class="comment">@'a';</span>
NSInteger number = 1;
NSNumber <span class="keyword">*</span>expressionNumber = <span class="comment">@(number);</span>
</code></pre><p>包括NSString,NSArray,NSDictionary都有这样的便捷写法，然而除了NSString可以用这种字面量来申明成静态变量，其他都不行，会报错</p>
<blockquote>
<p>initializer element is not a compile-time constant</p>
</blockquote>
<p>原因是这只是个让程序员方便的语法糖而已，能让我们创建一个 autoreleased的对象。</p>
<h4 id="慎用#define">慎用#define</h4><p>原因很简单，没有编译器检查，值可以更改而不提示。在实现文件中可以用static const，在头文件则可以使用extern。</p>
<p>需要注意的是，在头文件中的会注册到全局符号表，最好加上特殊前缀，避免重复。</p>
<h4 id="用枚举，而不是Bool">用枚举，而不是Bool</h4><p>记得曾经看着代码中一个个Bool变量，千万只草泥马飞奔而过，完全不知道该如何去理清逻辑，而枚举值可以比较清晰的表明不同状态。</p>
<p>现代Obj-C中尽量用NS_ENUM和NS_OPTIONS取代enum，前者可以方便的指定类型，后者可以用在一些条件是组合类型的情况。</p>
<pre><code><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, MyEnum) {
    &lt;<span class="preprocessor">#MyEnumValueA#&gt;,</span>
    &lt;<span class="preprocessor">#MyEnumValueB#&gt;,</span>
    &lt;<span class="preprocessor">#MyEnumValueC#&gt;,</span>
};

<span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, &lt;<span class="preprocessor">#MyEnum#&gt;) {</span>
    &lt;<span class="preprocessor">#MyEnumValueA#&gt; = 1 <span class="title">&lt;&lt; 0,
    &lt;#MyEnumValueB#&gt;</span> = 1 <span class="title">&lt;&lt; 1,
    &lt;#MyEnumValueC#&gt;</span> = 1 <span class="title">&lt;&lt; 2,
};</span></span>
</code></pre><p>最后一点就是和switch搭配使用的时候，不要加default分支。</p>
<h4 id="New_in_iOS7">New in iOS7</h4><p>1.instancetype<br>这个基本在现代话Obj-C中都改过来了，之前都是返回id，然而编译器并不能识别，不能够很好的提示，所以建议以后的初始化方法返回都用这个。</p>
<p>2.Modules</p>
<p>这个也是个好东西，可能你还没有使用，但其实编译器已经帮你优化了。PCH是曾经用来解决多出引用相同的模块，然而太容易被滥用了，最终的结果就是所有的文件引用都塞进去。</p>
<p>所以引入了module，在编译的时候加入一个Modules列表。如果在编译的文件中引用到某个Modules的话，先在这个列表内找，找到就用，如果没找到，则把该文件加入到这个表中。</p>
<h4 id="New_in_iOS9">New in iOS9</h4><p>1.Nullability</p>
<p>我觉得主要用在规范上，和下面说的范型是一样一样的，可以用来保证使用方按照我的节奏返回非空数值。</p>
<p>2.范型</p>
<p>Obj-C中两个让我头疼的点终于解决了一个，范型也是用在protocol中比较方便，约定好了数据，再也不用担心使用者乱来。</p>
<p>3.__kindof</p>
<p>还是用在协议中比较好，再也不需要用一个id来表示一类返回值了。</p>
<h3 id="对象，消息和运行时">对象，消息和运行时</h3><p>这一节个人感觉是iOS开发必须要掌握的，深入的理解Obj-C的对象和消息，掌握runtime才能写出高效的代码。正是有了运行时，让Obj-C和其他编译型语言有了很大的区别，当然也带了一些弊端（高效的内联函数，强类型检查等），不过总体来说给开发者带来了多元化的选择。</p>
<h4 id="属性究竟是什么鬼">属性究竟是什么鬼</h4><p>很长一段时间，其实我也没搞清楚属性究竟是干嘛的，直到有一天，我在protocol中定义了属性后，终于发现其实属性只是一种便捷方式。便捷的合成set，get方法，便捷的生产实例变量。</p>
<p>外部总应该通过属性来访问内部的数据，起到了一层过滤，保护的作用。同时属性还能附带很多特性（原子性，读写权等），熟练的使用属性能够方便的操作数据。</p>
<h4 id="属性Or实例变量">属性Or实例变量</h4><p>我个人是偏好使用属性的，但是在最近的使用过程中发现，有时候使用属性是有可能产生问题的，比如在继承关系中，比如在accessor方法中还有一些特殊的操作。</p>
<p>现在，在更多的内部使用中，我倾向于直接用实例变量，可以省去一步消息发送，减少内存管理时带来的负担（如果需要KVO或者懒加载则还是使用属性）。</p>
<h4 id="坑爹的对象比较">坑爹的对象比较</h4><p>由于Obj-C中不能操作符重载，所以对象的==比较其实比较的是指针值，经常出现的情况就是同样的NSString，然而比较下来并不相同。</p>
<p>所以Obj-C提供了一个方法来解决这个问题，isEqual。需要注意的是isEqual判定相等的两个对象hash值也必须相等，但是反过来却不是必要的。</p>
<h4 id="class_cluster">class cluster</h4><p>这个在Obj-C中很常见，大体上可以用工厂来实现，主要用于隐藏具体的细节，而又不想暴露不同的子类。在类别判断的时候尤其要小心，建议用category来扩展系统的class cluster，而不是继承。</p>
<h4 id="category中的“属性”">category中的“属性”</h4><p>有时候想给一个私有类添加属性并不一定要通过继承来实现，基于Obj-C的runtime机制，我们可以动态的给类添加“属性”。</p>
<pre><code>static char <span class="built_in">String</span>;
<span class="subst">-</span> (<span class="literal">void</span>)setString:(NSString <span class="subst">*</span>)<span class="built_in">string</span>{
    objc_setAssociatedObject(<span class="built_in">self</span>, <span class="subst">&amp;</span><span class="built_in">String</span>, <span class="built_in">string</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

<span class="subst">-</span> (NSString <span class="subst">*</span>)<span class="built_in">string</span>{
    <span class="keyword">return</span> objc_getAssociatedObject(<span class="built_in">self</span>, <span class="subst">&amp;</span><span class="built_in">String</span>);
}
</code></pre><p>关联对象很方便，但是却不推荐用，关联对象的清理等问题需要有一定的底层知识才能够理解的，而且不利于问题排查。</p>
<h4 id="消息发送和转发">消息发送和转发</h4><p>objc_msgSend这个函数虽然不常用，但其实无时不刻不在使用中，整个Obj-C的方法调用都是基于这个函数，区别于C语言的函数静态绑定，Obj-C可以推迟到运行时才决定方法调用（消息发送）。</p>
<p>当对象无法响应该消息时，就要用到消息转发机制了，分为两步：</p>
<p>1.动态添加方法</p>
<blockquote>
<p>+(BOOL)resolveInstanceMethod:(SEL)sel<br>+(BOOL)resolveClassMethod:(SEL)sel</p>
</blockquote>
<p>这两个方法会在第一时间被调用，在里面可以做很多小动作，比如说动态的添加方法。可以实现类似coredata的dynamic属性的accessor方法。</p>
<p>到这一步如果还不能响应，那么这个对象就会找备胎了。</p>
<blockquote>
<p>-(id)forwardingTargetForSelector:(SEL)aSelector</p>
</blockquote>
<p>通过这个返回值可以把消息转发给相应的对象，可以实现模拟多继承。</p>
<p>2.完整的消息转发</p>
<p>如果前面这些步骤都没能解决，那最后Obj-C就要寄出大招了，完整的消息转发</p>
<blockquote>
<p>-(void)forwardInvocation:(NSInvocation *)anInvocation;</p>
</blockquote>
<p>最后实在没辙就只能发给这个，系统默认是会抛出异常。</p>
<blockquote>
<p>-(void)doesNotRecognizeSelector:(SEL)aSelector;</p>
</blockquote>
<h4 id="method_swizzling">method swizzling</h4><p>这个技术其实很有用，不仅仅是在动态改变系统方法的实现，还可以完成AOP编程。</p>
<p>具体使用无非就是靠method_exchangeImplementaions来起到方法的实现互换。用在调试上比较方便，省去了在每个地方都写NSLog。</p>
<h4 id="类对象">类对象</h4><p>首先需要明确的一点就是Obj-C是一门动态语言，其次它也是一门依托于对象的语言。所以在Obj-C中类也是对象。</p>
<p>每个对象都有一个isa指针指向所属的类，为了形成完整的闭环，NSObject的metaclass的isa指向的是自己。</p>
<p>如果对象类型无法在编译器确定（id类型），那么可以通过内省来严格判断，并且尽量使用这样的方式而不是用==。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>其实很久以前就看过这本书了，在实践的过程中也不断的遵循着这些tips，不过随着时间的推移，苹果又加入了一些新元素，所以记录下来，不断的更新，完善这些iOS开发中需要注意的点。</p>
<h3 id="熟悉的Obj-C">熟悉的Obj-C</h3><p>这是一门很古老的语言了，古老到苹果已经推出新的语言来代替了，然而这也不能阻止我依然喜欢这门语言，虽然它还有很多缺陷，但也能看出苹果在不断的完善中。</p>]]>
    
    </summary>
    
      <category term="effective" scheme="http://blog.tracyone.com/tags/effective/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步一脚印封装CoreData]]></title>
    <link href="http://blog.tracyone.com/2015/07/01/%E4%B8%80%E6%AD%A5%E4%B8%80%E8%84%9A%E5%8D%B0%E5%B0%81%E8%A3%85CoreData/"/>
    <id>http://blog.tracyone.com/2015/07/01/一步一脚印封装CoreData/</id>
    <published>2015-07-01T15:03:13.000Z</published>
    <updated>2015-07-01T15:04:20.000Z</updated>
    <content type="html"><![CDATA[<p>CoreData是一种非常灵活地数据管理方式，它既不是一种O/RM也不是一个单纯地SQL wrapper，但是却有这两者的有点，也就是说你既可以把它用作对象关系映射，也可以简化数据库的操作。那么要熟练地使用coredata我们需要掌握哪些姿势呢？</p>
<p>整个coredata技术栈中从上游到下游大致有这些技术：</p>
<p>上层：NSManagedObject，NSEntityDescription，NSFetchRequest，NSPredicate，NSSortDescriptors</p>
<p>中层：NSManagedObjectContext，NSManagedObjectModel，NSPersistentStoreCoordinator</p>
<p>底层：NSPersistentStore，SQLite，NSFileManager</p>
<p>那么我们就可以按照这样的分层来组织我们的架构。代码可以在<a href="https://github.com/soochowtracy/TCTCoreData" target="_blank" rel="external">这里</a>下到</p>
<a id="more"></a>
<h3 id="TCTCoredata">TCTCoredata</h3><p>在这个架构模型当中最关键的就是位于中间这一层的对象。他们起到了呈上启下的作用，所以很明显我们需要封装一个类用来沟通系统暴露出来的接口和需要给上层提供的功能。</p>
<pre><code><span class="class"><span class="keyword">@interface</span> <span class="title">TCTCoreData</span> : <span class="title">NSObject</span></span>

+ (instancetype)defaultCoreData;

<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *modelName;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *storeFileName;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) TCTCoreDataStoreType storeType;

<span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSManagedObjectContext</span> *managedObjectMainContext;

<span class="keyword">@end</span>
</code></pre><p>接口这边的内容很简单就是context和全局的一个单例对象，支持一些自定义（model的名字，存储文件的名字等），其实整个这一层给上层提供的就是context这个容器。</p>
<pre><code>- (<span class="built_in">NSManagedObjectContext</span> *)managedObjectMainContext{
    <span class="keyword">if</span> (_managedObjectMainContext) {
        <span class="keyword">return</span> _managedObjectMainContext;
    }

    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.persistentStoreCoordinator</span>) {
        _managedObjectMainContext = [[<span class="built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="built_in">NSMainQueueConcurrencyType</span>];
        [_managedObjectMainContext setPersistentStoreCoordinator:<span class="keyword">self</span><span class="variable">.persistentStoreCoordinator</span>];
    }
    <span class="keyword">return</span> _managedObjectMainContext;
}

- (<span class="built_in">NSPersistentStoreCoordinator</span> *)persistentStoreCoordinator{
    <span class="keyword">if</span> (_persistentStoreCoordinator) {
        <span class="keyword">return</span> _persistentStoreCoordinator;
    }

    _persistentStoreCoordinator = [[<span class="built_in">NSPersistentStoreCoordinator</span> alloc] initWithManagedObjectModel:<span class="keyword">self</span><span class="variable">.managedObjectModel</span>];

    <span class="built_in">NSDictionary</span> *options = @{ <span class="built_in">NSMigratePersistentStoresAutomaticallyOption</span>: @YES,
                               <span class="built_in">NSInferMappingModelAutomaticallyOption</span>: @YES };


    <span class="built_in">NSURL</span> *fileURL = [[[<span class="keyword">self</span> applicationDocumentsDirectory] URLByAppendingPathComponent:<span class="keyword">self</span><span class="variable">.storeFileName</span>] URLByAppendingPathExtension:TCT_FileNameExtension(<span class="keyword">self</span><span class="variable">.storeType</span>)];
    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];

    <span class="keyword">if</span> (![fileManager fileExistsAtPath:[fileURL path]]) {
        <span class="built_in">NSURL</span> *storeURL = [<span class="keyword">self</span> URLOfFileName:<span class="keyword">self</span><span class="variable">.storeFileName</span> withExtension:TCT_FileNameExtension(<span class="keyword">self</span><span class="variable">.storeType</span>)];
        <span class="keyword">if</span> (storeURL) {
            [fileManager copyItemAtURL:storeURL toURL:fileURL error:<span class="literal">NULL</span>];
        }
    }

    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;
    <span class="keyword">if</span> (![_persistentStoreCoordinator addPersistentStoreWithType:TCT_StoreType(<span class="keyword">self</span><span class="variable">.storeType</span>) configuration:<span class="literal">nil</span> URL:fileURL options:options error:&amp;error]) {
<span class="preprocessor">#if DEBUG</span>
        [<span class="keyword">self</span> dealWithLinkStoreError:error];
<span class="preprocessor">#endif</span>
    }

    <span class="keyword">return</span> _persistentStoreCoordinator;
}

- (<span class="built_in">NSManagedObjectModel</span> *)managedObjectModel {
    <span class="keyword">if</span> (_managedObjectModel) {
        <span class="keyword">return</span> _managedObjectModel;
    }

    <span class="built_in">NSURL</span> *modelURL = [<span class="keyword">self</span> URLOfFileName:<span class="keyword">self</span><span class="variable">.modelName</span> withExtension:kModelNameExtension];

    _managedObjectModel = [[<span class="built_in">NSManagedObjectModel</span> alloc] initWithContentsOfURL:modelURL];

    <span class="keyword">return</span> _managedObjectModel;
}
</code></pre><p>具体的实现也很简单，主要就是从上而下的创建context，persistent和model。然后在这期间会运用到一些策略，比如说，自动升级，从bundle中拷贝sqlite文件等，主要是这一期是简单的封装，所以像数据库迁移，多context策略都没有写入。这个在后续版本迭代中会陆续改进。</p>
<p>在这个coredata栈建立中，还连接下层的：NSPersistentStore，SQLite，NSFileManager等，达到一个数据持久化的策略。</p>
<h3 id="TCTDatabaseHelper">TCTDatabaseHelper</h3><p>这一层就对应了上层的内容，对上层的内容做了简单地封装，本来是准备把NSPredicate和NSSortDescriptors封装进去的，后来考虑到这不是一个简单sql wrapper，所以觉得通过category来单独封装。</p>
<pre><code>+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">configureDatabaseWithSetting</span>:<span class="value">(TCTDatabaseSettingsBlock)setting</span></span>;

+ (<span class="tag">NSArray</span> *)<span class="rule"><span class="attribute">searchAllModelsWithEntityName</span>:<span class="value">(NSString *)entityName</span></span>;
+ (<span class="tag">NSArray</span> *)<span class="rule"><span class="attribute">searchModelsWithEntityName</span>:<span class="value">(NSString *)entityName predicate:(NSPredicate *)predicate sorts:(NSArray *)sorts</span></span>;

+ (<span class="tag">void</span>)<span class="rule"><span class="attribute">deleteAllModels</span>:<span class="value">(NSArray *)models</span></span>;
+ (<span class="tag">id</span>)<span class="rule"><span class="attribute">createModelWithEntityName</span>:<span class="value">(NSString *)entityName</span></span>;
+ (<span class="tag">BOOL</span>)<span class="tag">saveContext</span>;
</code></pre><p>除了第一个方法是用来对coredata配置外，其余均是用于对使用者提供的功能支持。其实对于使用方来说无非就是增删改查，怎么方便怎么来。然后又要结合对象管理，所以这里提供了增删查（在对象管理中，改需要先查出来后，修改对象属性，最后保存即可）。</p>
<pre><code>+ (<span class="built_in">NSArray</span> *)searchModelsWithEntityName:(<span class="built_in">NSString</span> *)entityName predicate:(<span class="built_in">NSPredicate</span> *)predicate sorts:(<span class="built_in">NSArray</span> *)sorts{
    <span class="built_in">NSFetchRequest</span> *request = [[<span class="built_in">NSFetchRequest</span> alloc] initWithEntityName:entityName];
    request<span class="variable">.predicate</span> = predicate;
    request<span class="variable">.sortDescriptors</span> = sorts;

    <span class="built_in">NSError</span> *error;
    <span class="built_in">NSArray</span>* objects = [[TCTCoreData defaultCoreData]<span class="variable">.managedObjectMainContext</span> executeFetchRequest:request error:&amp;error];

    <span class="keyword">if</span> (!objects) {
        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, error<span class="variable">.description</span>);
    }
    <span class="keyword">return</span> objects;

}
</code></pre><p>主要就是对fetch的组装，非常简洁，也为后续的扩展提供了可能性。那么到这里coredata的最基本封装要告一段落了，在这个过程中主要用到了NSManagedObject，NSEntityDescription，NSFetchRequest，NSManagedObjectContext，NSManagedObjectModel，NSPersistentStoreCoordinator，NSPersistentStore，SQLite，NSFileManager。后期的方向其实还有很多。</p>
<h3 id="下个版本迭代">下个版本迭代</h3><h5 id="异步中得数据库">异步中得数据库</h5><p>到现在为止，这个版本只能够在一个线程中访问，数据量大得情况下会卡主线程，按照我们老大的话来讲就是先等数据出来后再接入异步，程序总是在迭代中完善的。会用到的技术主要集中在contex中，主要用的策略还是单一Coordinator多context。</p>
<h5 id="更加复杂的版本升级">更加复杂的版本升级</h5><p>现在自动升级能够应对绝大多数情况，然而如果修改了entity结构，那么需要更加精准的映射，就需要引入NSMigrationManager，NSMappingModel，NSEntityMapping等类来辅助完成了。</p>
<h5 id="多样化的存储结构以及多个coredata的使用">多样化的存储结构以及多个coredata的使用</h5><p>当数据量达到一定级别后，当程序功能扩展后，为了逻辑上的清晰，工程的拆分，可能会在一个app中引入多个coredata，以及用不同的存储结构来持久化数据。</p>
<h3 id="总结">总结</h3><p>在整个coredata的封装过程中其实面临了两个个核心问题：</p>
<ol>
<li>是否要封装成一个大而全的工具？</li>
<li>是做一个中央管理式的工具，还是以实体对象来分散管理的数据库工具？</li>
</ol>
<p>没有哪种方案是绝对的好坏，至少在现在这个节点上，用最少的投入带来最大的产出是比较有利的，同时也希望这个库能够越来越完善，把该有的NSPredicate，NSSortDescriptors便捷方法补全等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>CoreData是一种非常灵活地数据管理方式，它既不是一种O/RM也不是一个单纯地SQL wrapper，但是却有这两者的有点，也就是说你既可以把它用作对象关系映射，也可以简化数据库的操作。那么要熟练地使用coredata我们需要掌握哪些姿势呢？</p>
<p>整个coredata技术栈中从上游到下游大致有这些技术：</p>
<p>上层：NSManagedObject，NSEntityDescription，NSFetchRequest，NSPredicate，NSSortDescriptors</p>
<p>中层：NSManagedObjectContext，NSManagedObjectModel，NSPersistentStoreCoordinator</p>
<p>底层：NSPersistentStore，SQLite，NSFileManager</p>
<p>那么我们就可以按照这样的分层来组织我们的架构。代码可以在<a href="https://github.com/soochowtracy/TCTCoreData">这里</a>下到</p>]]>
    
    </summary>
    
      <category term="CoreData" scheme="http://blog.tracyone.com/tags/CoreData/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法的思路]]></title>
    <link href="http://blog.tracyone.com/2015/06/30/%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>http://blog.tracyone.com/2015/06/30/算法的思路/</id>
    <published>2015-06-30T13:33:55.000Z</published>
    <updated>2015-07-01T02:37:54.000Z</updated>
    <content type="html"><![CDATA[<p>先说一个简单地题目，有一个无序的list里面存放了很多整数（有正有负），<br>如何去求出它的最小子序列和呢？（最小子序指的是连续的子list之和最小，如果都是正数则为0）</p>
<p>比如说有一个list = [1,-3,-2,5,2,-6],那么这个list的最小子序和则是-6，如果<br>list = [1,-3,-2,5,2,-4]，那么这个list的最小子序和则是-5.</p>
<a id="more"></a>
<h3 id="最简单的穷举法">最简单的穷举法</h3><p>这个问题初看很简单，就是两个循环记录每个子序的和，然后找出最小的和。很容易写出这样的算法：</p>
<pre><code><span class="keyword">int</span> subMin(<span class="keyword">int</span> *list, <span class="keyword">int</span> length){

    <span class="keyword">int</span> minSum = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; length; i++) {
        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j &lt; length; j++) {
            <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;
            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) {
                <span class="keyword">sum</span> += *(list+k);
            }

            <span class="keyword">if</span> (<span class="keyword">sum</span> &lt; minSum) {
                minSum = <span class="keyword">sum</span>;
            }
        }
    }

    <span class="keyword">return</span> minSum;
}
</code></pre><p>这个算法非常简单，思路也很清晰，既然需要求最小的那个子序，那我就列出每一个子序求和，得出最小的那个。第一个循环用来标记起始位，第二个循环标记结束位，最里面一层循环用来计算起始位到结束位的和。</p>
<h3 id="进击的穷举法">进击的穷举法</h3><p>这个算法虽然写起来很简单，但显而易见的时间复杂度非常高。这种思路下的算法只能作为备用，这种算法也有一个种称号叫穷举法。那么我们来看下这个算法是否还有改进的地方：</p>
<pre><code><span class="keyword">int</span> subMinUpgrade(<span class="keyword">int</span> *list, <span class="keyword">int</span> length){

    <span class="keyword">int</span> minSum = <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; length; i++) {

        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;
        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j &lt; length; j++) {

            <span class="keyword">sum</span> += *(list + j);

            <span class="keyword">if</span> (<span class="keyword">sum</span> &lt; minSum) {
                minSum = <span class="keyword">sum</span>;
            }
        }
    }

    <span class="keyword">return</span> minSum;
}
</code></pre><p>经过分析，其实能发现，第三层的循环是多余的，因为在第二层循环的时候已经能够穷举每一种情况了，只是不够直观，这个思路利用了在建立穷举界限的步骤中加入运算的步骤来简化。很明显时间复杂度下降了一个量级。但是这就是一个我们所追求的好的算法么！</p>
<h3 id="分治的思路">分治的思路</h3><p>归根到底，这种算法也还是一种穷举法，会遍历所有的情况，既然这样，那我能不能每次循环中做的事情更多一点，或者能不能减少循环的次数呢？带着这样的想法，我尝试了把这个队列一分为二，这样我就能减少循环次数了，但是分成两份后怎样去求最小的子序和呢？</p>
<p>举个例子：30,-25,14,-24,1,35,-25,10，这个list。想要求出最小值我们其实可以求左边4个的最小值，或者右边4个的最小值，然后求出横跨两边的最小值，最后求出这三者的最小值，那就是我们需要的最小值。</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">subMinRecursion</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">list</span>, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>{
    <span class="keyword">int</span> minSumLeft = <span class="number">0</span>;
    <span class="keyword">int</span> minSumRight = <span class="number">0</span>;

    <span class="keyword">int</span> sumLeftCross = <span class="number">0</span>;
    <span class="keyword">int</span> minSumLeftCross = <span class="number">0</span>;

    <span class="keyword">int</span> sumRightCross = <span class="number">0</span>;
    <span class="keyword">int</span> minSumRightCross = <span class="number">0</span>;

    <span class="keyword">if</span> (start == end) {
        <span class="keyword">if</span> (*(<span class="built_in">list</span>+start) &gt; <span class="number">0</span>) {
            <span class="keyword">return</span> <span class="number">0</span>;
        }<span class="keyword">else</span>{
            <span class="keyword">return</span> *(<span class="built_in">list</span>+start);
        }
    }<span class="keyword">else</span>{

        <span class="keyword">int</span> mid = (end + start)/<span class="number">2</span>;


        minSumLeft = subMinRecursion(<span class="built_in">list</span>, start, mid);
        minSumRight = subMinRecursion(<span class="built_in">list</span>, mid+<span class="number">1</span>, end);

        <span class="keyword">for</span> (<span class="keyword">int</span> i = end/<span class="number">2</span>; i &gt;= start; i--) {
            sumLeftCross += *(<span class="built_in">list</span>+i);

            <span class="keyword">if</span> (sumLeftCross &lt; minSumLeftCross) {
                minSumLeftCross = sumLeftCross;
            }
        }

        <span class="keyword">for</span> (<span class="keyword">int</span> i = end/<span class="number">2</span> + <span class="number">1</span>; i &lt;= end; i++) {
            sumRightCross += *(<span class="built_in">list</span>+i);

            <span class="keyword">if</span> (sumRightCross &lt; minSumRightCross) {
                minSumRightCross = sumRightCross;
            }
        }

        <span class="keyword">return</span> minOfThree(minSumLeft, minSumRight, minSumLeftCross + minSumRightCross);

    }
}
</code></pre><p>很长但是也很好理解，每次的在最小值的计算都是基于子list的最小值，如果是正数就返回0表示排除。总的来说时间复杂度在NlogN级别。</p>
<p>那么为什么这个算法可以降低时间复杂度呢，原因就在于他用到了分治的思路，每一次循环都能减少前一次一半的情况，这样的思路我们可以运用到很多场景，比如说二分查找，二分排序等，包括二叉树建立的思路也是这样的。</p>
<h3 id="换个角度">换个角度</h3><p>这里先给出程序，让我们来看下这样的问题还能玩出什么花样?</p>
<pre><code>int subM<span class="keyword">in</span>Other(int* list, int length){
    int sumSubM<span class="keyword">in</span> = <span class="number">0</span>;
    int minSumSubM<span class="keyword">in</span> = <span class="number">0</span>;

    <span class="keyword">for</span> (int i=<span class="number">0</span>; i &lt; length; i++) {
        sumSubM<span class="keyword">in</span> += *(list+i);

        <span class="keyword">if</span> (sumSubM<span class="keyword">in</span> &lt; minSumSubM<span class="keyword">in</span>) {
            minSumSubM<span class="keyword">in</span> = sumSubM<span class="keyword">in</span>;
        }<span class="keyword">else</span> <span class="keyword">if</span>(sumSubM<span class="keyword">in</span> &gt; <span class="number">0</span>){
            sumSubM<span class="keyword">in</span> = <span class="number">0</span>;
        }
    }

    <span class="built_in">return</span> minSumSubM<span class="keyword">in</span>;
}
</code></pre><p>这里主要就用到了一个技巧，就是如果连续的累加值超过0了那可以把前面的累加值看成0，而只需要用另外一个变量记录下来之前的最小值，然后反复不断的查找一段一段的最小值，直到最后找出真实最小的那一个值。</p>
<h3 id="总结">总结</h3><p>那么这样的一个例子说明了什么呢？总的来说，碰到任何问题，穷举总是能解决问题的，但是在有限的资源下，如何更好地利用就是我们需要思考的问题，很多人要问就算我知道了这样的解法有什么用呢？不说别的单单指这一个例子就能运用到很多地方。</p>
<p>比如说，以前玩游戏经常买卖装备赚差价，有时候高有时候低，如果做一个统计以后，最后就能得出大致在什么时间点是能够卖得最高的，那今后就能够利用这个点去赚钱，再比如说，每个公司都有自己的数据统计，如何从海量的数据中找出那个最有价值的数据。</p>
<p>最后再附上一道题目一起来思考下如何用有限的资源完成无限的可能：<br>假设有一个文件，包含了1000万条数据，每条数据都是一个7位整数，并且没有重复（e.g 00000000-9999999），在最多只有1M内存空间可用的情况下，如何进行排序呢？当然运行时间越少越好。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>先说一个简单地题目，有一个无序的list里面存放了很多整数（有正有负），<br>如何去求出它的最小子序列和呢？（最小子序指的是连续的子list之和最小，如果都是正数则为0）</p>
<p>比如说有一个list = [1,-3,-2,5,2,-6],那么这个list的最小子序和则是-6，如果<br>list = [1,-3,-2,5,2,-4]，那么这个list的最小子序和则是-5.</p>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://blog.tracyone.com/tags/algorithm/"/>
    
      <category term="DataStructures &amp; Algorithm" scheme="http://blog.tracyone.com/categories/DataStructures-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初探GCD]]></title>
    <link href="http://blog.tracyone.com/2015/06/28/%E5%88%9D%E6%8E%A2GCD/"/>
    <id>http://blog.tracyone.com/2015/06/28/初探GCD/</id>
    <published>2015-06-28T10:08:41.000Z</published>
    <updated>2015-06-28T10:11:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="GCD简介">GCD简介</h2><p>GCD是一种简洁的多线程编程技术，通过配合Block让我们平时在需要用到异步时可以简单地使用，而不需要考虑线程的建立，调度等问题。XNU内核通过上下文切换来完成任务的调度（线程就是任务调度的抽象），不过这也带来了一些问题，比如说数据竞争，死锁，消耗内存等，为了解决这些问题，编程会变得很复杂，而GCD大大地简化了多线程编程的难度。</p>
<h2 id="GCD技能树">GCD技能树</h2><a id="more"></a>
<h3 id="Dispatch_Queue">Dispatch Queue</h3><p>首先要申明一点，queue不等于线程，多个queue也不代表了多个线程，一个queue也可能对应了多个线程，这里的queue其实是一个存放task的队列，遵循先进先出原则。</p>
<p>Queue可以分两种，一种是serial，一种concurrent，一个serial队列只有一个线程执行任务，也就是说这是需要等待正在处理的任务结束了CGD才会分发第二个任务进行处理，而concurrent则不一样，它对应了很多个线程（视具体处理器，程序运行情况而定）。</p>
<h4 id="dispatch_queue_create">dispatch_queue_create</h4><pre><code><span class="built_in">dispatch_queue_t</span> tempQueue = dispatch_queue_create(<span class="string">"com.LY.Test"</span>, <span class="literal">NULL</span>);
</code></pre><p>通过这种方法可以创建一个队列，通过改变第二个参数，可以指定是serial还是concurrent模式（DISPATCH_QUEUE_CONCURRENT）。还有一点比较好的地方就是ARC后编译器已经可以帮我们管理内存了，也就是把GCD对象看成OC对象了。</p>
<p>虽然我们可以创建多个serial队列来模拟concurrent队列，不过这会消耗很大的性能，因为每一个serial都会阐述一个线程，必然带来了大量的内存消耗。而concurrent队列则不一样，由系统帮我们觉得是否开辟新线程，还是使用原有的线程。</p>
<h4 id="Main/Global_Dispatch_Queue">Main/Global Dispatch Queue</h4><pre><code>dispatch_queue_t tempQueue = dispatch_get_main_queue<span class="list">()</span><span class="comment">;</span>
dispatch_queue_t tempQueue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_HIGH</span>, <span class="number">0</span>)</span><span class="comment">;</span>
</code></pre><p>第一个队列从名字就能看出来对应了主线程，是一个serial队列。第二个则是一个concurrent队列有四种优先级（DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_PRIORITY_DEFAULT,DISPATCH_QUEUE_PRIORITY_LOW,DISPATCH_QUEUE_PRIORITY_BACKGROUND），其实这也只能说是一个大概的优先级区别，并不是说后台队列就只能用在后台。</p>
<h4 id="dispatch_set_target_queue">dispatch_set_target_queue</h4><p>系统级的队列不需要我们设立优先级，当我们自己创建队列时，默认都是DISPATCH_QUEUE_PRIORITY_DEFAULT级别的。</p>
<pre><code>dispatch_queue_t tempQueue = dispatch_queue_create<span class="list">(<span class="string">"com.LY.test"</span>, NULL)</span><span class="comment">;</span>
dispatch_queue_t bgQueue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_BACKGROUND</span>, <span class="number">0</span>)</span><span class="comment">;</span>
dispatch_set_target_queue<span class="list">(<span class="keyword">tempQueue</span>, bgQueue)</span><span class="comment">;</span>
</code></pre><p>这个函数还有一个作用，能够建立“依赖”，这里的依赖要打个引号，其实只是相当于把多个serial队列的target设为统一serial队列，那么能够起到本来是并发执行的各个serial队列，现在每次只能有一个任务在执行中。</p>
<pre><code>dispatch_queue_t tempQueue = dispatch_queue_create<span class="list">(<span class="string">"com.LY.test"</span>, NULL)</span><span class="comment">;</span>
dispatch_queue_t temp2Queue = dispatch_queue_create<span class="list">(<span class="string">"com.LY.test1"</span>, NULL)</span><span class="comment">;</span>
dispatch_queue_t temp1Queue = dispatch_queue_create<span class="list">(<span class="string">"com.LY.test2"</span>, NULL)</span><span class="comment">;</span>
dispatch_set_target_queue<span class="list">(<span class="keyword">temp1Queue</span>, tempQueue)</span><span class="comment">;</span>
dispatch_set_target_queue<span class="list">(<span class="keyword">temp2Queue</span>, tempQueue)</span><span class="comment">;</span>

dispatch_async<span class="list">(<span class="keyword">temp1Queue</span>, ^{
         NSLog<span class="list">(@<span class="string">"1"</span>)</span><span class="comment">;</span>
        sleep<span class="list">(<span class="number">3</span>)</span><span class="comment">;</span>

    })</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">temp2Queue</span>, ^{
        NSLog<span class="list">(@<span class="string">"2"</span>)</span><span class="comment">;</span>
    })</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">temp1Queue</span>, ^{
            NSLog<span class="list">(@<span class="string">"3"</span>)</span><span class="comment">;</span>
        })</span><span class="comment">;</span>
</code></pre><p>如果没有设置target的话，这里的输出是1 2 3；加了同一个target后就变成1 3 2了。</p>
<h3 id="Dispatch_组合技">Dispatch 组合技</h3><h3 id="Dispatch_同步/异步">Dispatch 同步/异步</h3><pre><code><span class="built_in">dispatch_sync</span>
<span class="built_in">dispatch_async</span>
dispatch_barrier_sync
dispatch_barrier_async
</code></pre><p>这里有一个点很重要，同步/异步，阻塞/非阻塞其实是两个概念，一个关注的消息通信机制，一个关注的是程序在等待时的状态。</p>
<h3 id="Dispatch_Group">Dispatch Group</h3><p>这个用处就多了，最基本的用法，先执行一系列的任务，等这些都执行完了，再执行一个特殊的任务。如果用普通的queue来实现会增加很多不必要的操作。这里用gruop来实现就很简单了。</p>
<pre><code> dispatch_queue_t queue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><span class="comment">;</span>
dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span>

dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^{
    NSLog<span class="list">(@<span class="string">"1"</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^{
    NSLog<span class="list">(@<span class="string">"2"</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^{
    NSLog<span class="list">(@<span class="string">"3"</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>

dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^{
    NSLog<span class="list">(@<span class="string">"main"</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
</code></pre><p>这里的执行结果肯定的是main是最后一个打印的。</p>
<ul>
<li>这个可以阻塞当前线程直到group中得任务全部执行结束。dispatch_group_wait(group, DISPATCH_TIME_FOREVER);</li>
<li>这个可以检测当前group是否已经全部执行完。long result = dispatch_group_wait(group, DISPATCH_TIME_NOW);</li>
</ul>
<p>通过调节时间可以完成各种花样。</p>
<h3 id="Dispatch_Barrier">Dispatch Barrier</h3><p>有时候我们想在一个并发队列中存在一个任务以serial的形式执行，这时候我们就需要用到barrier</p>
<pre><code>dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.LY.test"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, ^{
    NSLog<span class="list">(@<span class="string">"1"</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, ^{
    NSLog<span class="list">(@<span class="string">"1"</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, ^{
    NSLog<span class="list">(@<span class="string">"1"</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
dispatch_barrier_async<span class="list">(<span class="keyword">queue</span>, ^{
    NSLog<span class="list">(@<span class="string">"barrier"</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, ^{
    NSLog<span class="list">(@<span class="string">"2"</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, ^{
    NSLog<span class="list">(@<span class="string">"2"</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
</code></pre><p>不管前面三个什么时候结束，可以肯定的是2 2肯定是在1 1 1 barrier后面出现。</p>
<h3 id="Dispatch_Semaphore">Dispatch Semaphore</h3><p>这个可以更加精细化的处理并发时的数据不一致问题，从名字上能够看出来这是通过信号来处理的，只有在信号大于0的时候不需要等待。</p>
<pre><code>  dispatch_queue_t queue = dispatch_get_global_queue<span class="params">(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>)</span>;
dispatch_semaphore_t semaphore = dispatch_semaphore_create<span class="params">(<span class="number">1</span>)</span>;
NSMutableArray <span class="built_in">*</span>arr = [NSMutableArray array];

<span class="keyword">for</span> <span class="params">(int i=<span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span> {
    dispatch_async<span class="params">(queue, ^{
        dispatch_semaphore_wait<span class="params">(semaphore, DISPATCH_TIME_FOREVER)</span>;

        [arr addObject:@<span class="params">(i)</span>];

        dispatch_semaphore_signal<span class="params">(semaphore)</span>;
    })</span>;
}

<span class="keyword">for</span> <span class="params">(NSNumber *n in arr)</span> {
    NSLog<span class="params">(@<span class="string">"%@"</span>, n)</span>;
}
</code></pre><p>结果是从0-9999按序输出，用法：先创建一个semaphore，然后通过dispatch_semaphore_wait来判断是否需要等待，等待多长时间，通过dispatch_semaphore_signal这个函数来给计数加1.</p>
<h3 id="Dispatch小技巧">Dispatch小技巧</h3><h4 id="dispatch_after">dispatch_after</h4><p>这个就比较简单了，其实就是延时用dispatch_async添加到队列中,不会阻塞当前线程。</p>
<pre><code>dispatch_time_t time = dispatch_time<span class="params">(DISPATCH_TIME_NOW, <span class="params">(int64_t)</span><span class="params">(<span class="number">2</span>ull * NSEC_PER_SEC)</span>)</span>;
dispatch_after<span class="params">(time, dispatch_get_main_queue<span class="params">()</span>, ^{
    NSLog<span class="params">(@<span class="string">"deley"</span>)</span>;
})</span>;
</code></pre><h4 id="dispatch_apply">dispatch_apply</h4><p>这个可以解决单次循环比较耗时的问题。配合async使用效果更加。</p>
<pre><code>dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"com.LY.test"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span>
dispatch_apply<span class="list">(<span class="number">10</span>, queue, ^<span class="list">(<span class="keyword">size_t</span> <span class="literal">t</span>)</span> {
    NSLog<span class="list">(@<span class="string">"%@"</span> , @<span class="list">(<span class="keyword">t</span>)</span>)</span><span class="comment">;</span>
})</span><span class="comment">;</span>
</code></pre><h4 id="dispatch_suspend/resume">dispatch_suspend/resume</h4><p>这个从字面上就能看出，一个是挂起队列，一个是重新开始执行，需要注意的是已经在执行的任务是无法挂起的。</p>
<h2 id="GCD实现&amp;&amp;总结">GCD实现&amp;&amp;总结</h2><p>GCD虽然源码已经放出来了，不过从中可以看出，苹果用了很多手法来反编译，全是混淆，也导致阅读难度大量增加。</p>
<p>总的来说，Dispatch Queue主要用到<a href="http://opensource.apple.com/source/libdispatch/" target="_blank" rel="external">libdispatch</a>，Libc，以及XNU内核中得workqueue。而我们作为一个普通开发所使用的大多都在libdispatch中。</p>
<p>大致的原理是，通过结构体和链表实现FIFO队列，然后其他函数辅助，其中Block不是直接加入队列，中间会转一层。</p>
<p>具体的源码解析，还有dispatch的source放到以后再说，这次主要记录一下整个dispatch的基本使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="GCD简介">GCD简介</h2><p>GCD是一种简洁的多线程编程技术，通过配合Block让我们平时在需要用到异步时可以简单地使用，而不需要考虑线程的建立，调度等问题。XNU内核通过上下文切换来完成任务的调度（线程就是任务调度的抽象），不过这也带来了一些问题，比如说数据竞争，死锁，消耗内存等，为了解决这些问题，编程会变得很复杂，而GCD大大地简化了多线程编程的难度。</p>
<h2 id="GCD技能树">GCD技能树</h2>]]>
    
    </summary>
    
      <category term="GCD" scheme="http://blog.tracyone.com/tags/GCD/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS开发应该知道的HTTP]]></title>
    <link href="http://blog.tracyone.com/2015/06/22/iOS%E5%BC%80%E5%8F%91%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84HTTP/"/>
    <id>http://blog.tracyone.com/2015/06/22/iOS开发应该知道的HTTP/</id>
    <published>2015-06-22T05:50:57.000Z</published>
    <updated>2015-06-23T02:33:12.000Z</updated>
    <content type="html"><![CDATA[<p>前一阵子和同事讨论是否应该全部迁徙到HTTPS请求，由此引发了对整个HTTP协议的研究的想法，然后找了一本小学生也能看懂的关于HTTP协议的书《图解HTTP》，津津有味的翻了一遍，做个总结，下文主要以问答的形式组织，也为了以后方便回顾，查阅。(如有侵权，请及时联系)</p>
<h2 id="了解Web及网络基础">了解Web及网络基础</h2><p>1.WWW的构建技术有：</p>
<ul>
<li>作为页面的文本标记语言的HTML</li>
<li>作为文本传输协议的HTTP</li>
<li>作为指定文档位置的URL</li>
</ul>
<a id="more"></a>
<p>2.网络基础TCP/IP协议簇</p>
<ul>
<li>应用层：FTP,HTTP,DNS等（决定了向用户提供什么服务）</li>
<li>传输层：TCP，UDP（提供处于网络连接中得两台计算机的数据传输）</li>
<li>网络层：IP（处理网络上流动的数据包，规定了通过怎样的路径传送）</li>
<li>链路层：用于处理网络连接的硬件部分</li>
</ul>
<p>3.与HTTP协议密切相关的三个协议</p>
<ol>
<li>IP协议： 要确保数据传送对象正确，有两个重要的因素就是IP地址和MAC地址，IP间的通信依赖于MAC地址，通过ARP协议反查出对应的MAC地址。</li>
<li>TCP协议： 在传输的过程中，会把大块的数据切割成报文段的数据包管理，而TCP就是为了解决在这个过程中产生的不确定因素，建立一个可靠地链接。主要通过三次握手和四次挥手。</li>
<li>DNS服务：主要提供了域名到IP地址间的解析，因为域名容易记，所以大多数情况我们是通过域名访问主机。</li>
</ol>
<p>4.URL的组成部分</p>
<p><code>http://user:passwd@blog.tracyone.com:80/index//2015/06/18/iOS/XXX?userid=1#more</code></p>
<p>协议名称，登陆信息，服务器地址，服务器端口号，文件路径，查询条件，片段标示符</p>
<h2 id="初识HTTP协议">初识HTTP协议</h2><p>1.HTTP协议特点</p>
<ul>
<li>肯定有一端是客户端，另一端是服务端，有时可能互换角色。</li>
<li>规定请求从客户端发起，服务端响应，不会主动响应。</li>
<li>是一种无状态协议，也就是说不做持久化处理。</li>
<li>通过URL定位，通过方法（GET，POST等）告知服务端执行的操作。</li>
</ul>
<p>2.HTTP协议中的连接 </p>
<ol>
<li><p>持久连接：在刚开始的版本中，每执行一次HTTP请求就会建立一次TCP连接，后来发现这样的开销很大，为了解决这个问题，引入了持久连接。好处就是，减少了TCP连接的重复建立和断开造成的开销。</p>
</li>
<li><p>管线化：正是由于持久连接使得请求以pipelining方式发送成为可能性，不用等待前一个请求返回就能发起下一个请求。</p>
</li>
</ol>
<p>3.Cookie带来的状态管理</p>
<p>Cookie会根据服务端发送的响应中设置一个字段，下一次客户端再次访问的时候会带上这个字段，然后发送给服务端，服务端根据这个字段校验。</p>
<h2 id="HTTP报文">HTTP报文</h2><p>HTTP报文是指通过HTTP协议交互的信息（请求报文，响应报文），大致可以分为报文首部和报文主体两块。</p>
<p>1.提升传输速率</p>
<ul>
<li>压缩传输的内容（gzip，compress，zlib）</li>
<li>分割分块传输</li>
<li>发送多种数据的对象集合（multipart/from-data,multipart/byteranges）</li>
</ul>
<p>2.状态码大致分类</p>
<ul>
<li>1XX（信息性状态码）：接收的请求正在处理</li>
<li>2XX（成功状态码）：请求正常处理结束</li>
<li>3XX（重定向状态码）：需要进行附加操作</li>
<li>4XX（客户端错误状态码）：服务器无法处理</li>
<li>5XX （服务端错误状态码）：服务端处理出错</li>
</ul>
<p>3.四种HTTP首部字段类型</p>
<ul>
<li>通用首部字段（Cache-Control,Date,Via等）</li>
<li>请求首部字段（Accept,Host,User-Agent等）</li>
<li>响应首部字段（Server,Location等）</li>
<li>实体首部字段（Content-Encoding,Allow等）</li>
</ul>
<h2 id="与HTTP协作的Web服务器">与HTTP协作的Web服务器</h2><p>1.通信数据的转发程序</p>
<ul>
<li>代理：主要是做客户端和服务端的中间人作用，可以利用缓存技术减少网络带宽流量，获取访问日记等。</li>
<li>网关：可以使通信线路上得服务器提供非HTTP请求，提高通信的安全性。</li>
<li>隧道：确保客户端和服务端通信安全，隧道本身是透明的。</li>
</ul>
<p>2.HTTP使用的认证方式</p>
<ul>
<li>BASIC认证（客户端发起请求-服务端返回401请求认证-客户端base64编码发送认证-成功返回200失败返回401）</li>
<li>DIGEST认证（客户端发送请求-服务端返回临时质询码-客户端发送摘要及响应码-成功返回200失败返回401）</li>
<li>SSL客户端认证（接收到认证资源请求后，服务端会发送request报文要求客户端提供证书-客户端发送证书-服务端验证通过后进行HTTPS加密通信）</li>
<li>FormBase认证（基于表单的认证也就是根据不同的Web应用，会让你输入账户密码等认证行为，一般通过cookie来记录状态）</li>
</ul>
<h2 id="HTTP扩展出来的协议">HTTP扩展出来的协议</h2><p>1.HTTP的缺点</p>
<ul>
<li>通信使用明文，内容很容易被窃取</li>
<li>不需要验证身份，可能遭遇伪装</li>
<li>无法验证报文完整性，有可能被篡改</li>
</ul>
<p>2.HTTPS = HTTP+加密+认证+完整性保护</p>
<ul>
<li>客户端发送报文开始SSL通信，报文中包含SSL版本，加密组件等</li>
<li>服务端可进行SSL通信时，返回SSL版本和加密组件等</li>
<li>服务器发送证书报文</li>
<li>服务器发送报文通知SSL握手协商结束</li>
<li>客户端发送报文回应，并发送一段随机码用证书中得公钥加密过</li>
<li>客户端再发送报文提示服务端以后通信会用这个密钥加密</li>
<li>客户端发送结束报文</li>
<li>服务端同样发送确认用该密钥加密</li>
<li>服务端发送结束报文</li>
</ul>
<p>3.HTTP的瓶颈：</p>
<ul>
<li>一个连接只能发送一个请求</li>
<li>请求只能由客户端发起</li>
<li>首部没有经过压缩</li>
<li>发送冗长的首部（每次都需要发）</li>
<li>没有强制压缩发送</li>
</ul>
<p>4.SPDY的功能：</p>
<ul>
<li>多路复用流</li>
<li>赋予请求优先级</li>
<li>压缩HTTP首部</li>
<li>推送功能</li>
<li>服务器提示功能</li>
</ul>
<p>5.WebSocket的功能 </p>
<ul>
<li>推送功能</li>
<li>减少通信量</li>
<li>握手请求，响应</li>
</ul>
<h2 id="针对Web的攻击技术">针对Web的攻击技术</h2><p>1.因输出值转移不完全引发的安全漏洞</p>
<ul>
<li>跨站脚本攻击（是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或者JS进行攻击）</li>
<li>SQL注入攻击（针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击）</li>
<li>OS命令注入攻击（通过Web应用，执行非法的操作系统命令达到攻击的目的，调用shell函数）</li>
<li>HTTP首部注入攻击（通过在响应首部字段内插入换行，天剑任意响应首部或者主题的一种攻击）</li>
<li>邮件首部注入攻击（通过向邮件首部To或者Subject内任意添加非法内容引起的攻击）</li>
<li>目录遍历攻击（是指对本无意公开的目录，通过非法截断目录路径，达成访问目录的攻击）</li>
<li>远程文件包含漏洞（是指当部分脚本内容需要读取其他文件时，攻击者利用指定外部服务器的URL充当以来文件）</li>
</ul>
<p>2.因设置或设计上缺陷引发的安全漏洞 </p>
<ul>
<li>强制浏览（从安置Web服务器的公开目录下地文件中，浏览那些原本非自愿公开的文件）</li>
<li>不正确地错误消息处理（是指Web应用的错误消息内包含对攻击者有效地信息）</li>
<li>开放重定向（是一种对指定的URL做重定向跳转的功能）</li>
</ul>
<p>3.因会话管理疏忽引发的安全漏洞</p>
<ul>
<li>会话劫持（指攻击者通过某种手段拿到了用户的会话ID，伪装成用户）</li>
<li>会话固定攻击（强制用户使用攻击者指定的会话ID）</li>
<li>跨站点请求伪造（攻击者通过设置好陷阱，强制对已完成认证的用户信息更新和状态更新）</li>
</ul>
<p>4.其他安全漏洞</p>
<ul>
<li>密码破解（算出密码，突破认证）</li>
<li>点击劫持（利用透明的按钮或者链接覆盖在Web页面上）</li>
<li>Dos攻击（是一种让运行中得服务呈现停止状态的攻击）</li>
<li>后门程序 （是指开发设置的隐藏入口，可不按正常步骤使用受限功能）</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>前一阵子和同事讨论是否应该全部迁徙到HTTPS请求，由此引发了对整个HTTP协议的研究的想法，然后找了一本小学生也能看懂的关于HTTP协议的书《图解HTTP》，津津有味的翻了一遍，做个总结，下文主要以问答的形式组织，也为了以后方便回顾，查阅。(如有侵权，请及时联系)</p>
<h2 id="了解Web及网络基础">了解Web及网络基础</h2><p>1.WWW的构建技术有：</p>
<ul>
<li>作为页面的文本标记语言的HTML</li>
<li>作为文本传输协议的HTTP</li>
<li>作为指定文档位置的URL</li>
</ul>]]>
    
    </summary>
    
      <category term="http" scheme="http://blog.tracyone.com/tags/http/"/>
    
      <category term="Computer Networks" scheme="http://blog.tracyone.com/categories/Computer-Networks/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS菜鸟的CS之路（计算机系统漫游）]]></title>
    <link href="http://blog.tracyone.com/2015/06/18/iOS%E8%8F%9C%E9%B8%9F%E7%9A%84CS%E4%B9%8B%E8%B7%AF%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8%EF%BC%89/"/>
    <id>http://blog.tracyone.com/2015/06/18/iOS菜鸟的CS之路（计算机系统漫游）/</id>
    <published>2015-06-18T15:08:16.000Z</published>
    <updated>2015-06-20T02:36:40.000Z</updated>
    <content type="html"><![CDATA[<p>计算机系统是由硬件+软件构成，共同工作来运行应用程序。这里由一个非常简单的例子入手观察在整个程序生命周期中，计算机系统分别承担了什么样的责任。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio,h&gt;</span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="built_in">printf</span>(<span class="string">"hello, world"</span>);
}
</code></pre><h2 id="系统简介">系统简介</h2><h3 id="信息就是位+上下文">信息就是位+上下文</h3><p>这是一个很简单的C语言源程序，在计算机系统中，像这样的源程序一般都是由ASCⅡ字符构成，也称为文本文件，其他文件则称为二进制文件。这也透露出来一个基本的理念：系统中所有的信息（磁盘上，存储器中，网络中）都是由一串位表示的，唯一区别只是上下文。</p>
<a id="more"></a>
<h3 id="程序被其他程序翻译成不同的格式">程序被其他程序翻译成不同的格式</h3><p>本身hello程序没有任何意义，只是一个简单地C语言源程序，能够被人读懂，然而系统却不认识。但是经过编译系统一系列的处理过后，最终会成为一个可执行的目标程序。具体的翻译过程是这样的：</p>
<p>hello.c  - (预处理器) - hello.i    - (编译器) - hello.s - (汇编器) - hello.o - (链接器) - hello</p>
<ul>
<li>预处理阶段，经过预处理器展开预处理程序，填充stdio库中的程序得到另一个C程序，通常用.i做后缀。</li>
<li>编译阶段，经过编译器翻译成汇编程序，这时候语言已经很接近机器指令了，<code>不同的的高级语言，不同的编译器，最终得到的却是通用的汇编程序</code></li>
<li>汇编阶段，通过汇编器将汇编程序翻译成机器语言指令，然后打包成一种叫<code>relocatable object program</code>格式的目标文件</li>
<li>链接阶段，链接器把不同的目标程序链接合并处理，最终产出一个可执行文件。</li>
</ul>
<h3 id="了解编译系统如何工作的益处">了解编译系统如何工作的益处</h3><ul>
<li><p>优化程序性能 （一个switch语句是否总是比一系列if-else高校，一个函数调用的开销有多大，while和for哪个更有效，指针还是数组等等）</p>
</li>
<li><p>理解链接时出现的错误 （很长时间，在链接过程的错误总是最让人头疼的，静态库和动态库的区别，有些问题会知道运行时才暴露等等）</p>
</li>
<li><p>避免安全漏洞 （缓冲区溢出是困扰网络和Internet服务器上安全漏洞的主要原因）</p>
</li>
</ul>
<h2 id="处理器">处理器</h2><h3 id="处理器读并解释存储在存储器中得指令">处理器读并解释存储在存储器中得指令</h3><p>当前面的程序已经翻译成一个可执行程序后，我们开始在操作系统上执行，会在控制台上打印出hello， world这些内容，那么这之间发生了什么呢？</p>
<h5 id="硬件组成">硬件组成</h5><ul>
<li><p>总线 （通常总线被设计成传送定长的字节块，其中字节长是一个基本系统参数，比如常用的32位，64位分别对应了4字节长，和8字节长。）</p>
</li>
<li><p>I/O设备 （这是一个很广的概念，鼠标，键盘，显示器属于I/O设备，硬盘等也是。一种是本身就在主板上，一种是适配器插上去。）</p>
</li>
<li><p>主存 （也称为内存，是由一组DRAM芯片组成，是一个线性的字节数组，每个字节都有一个唯一的地址，从零开始。一般来说不同的机器，指令的长度不相同。）</p>
</li>
<li><p>处理器 （CPU，简称处理器，用来执行存储在主存中指令的引擎，由寄存器，程序计数器（PC），算数/逻辑单元（ALU）组成。）</p>
</li>
</ul>
<h5 id="软件运行">软件运行</h5><p>在整个运行期间，先把存放在磁盘上得可执行文件传送到主存（通过直接存储器（DMA）），然后再到寄存器。</p>
<h3 id="高速缓存的重要性">高速缓存的重要性</h3><p>前面整个过程可以看出，有大量的时间是用在资源的传输上，于是聪明的系统设计者就在处理器和主存间加入了<code>高速缓存存储器</code>，访问速度几乎和寄存器一样快。L1和L2运用的是一种静态随机访问存储器（SRAM）的硬件技术实现，现在很多还加入了L3缓存。</p>
<h3 id="存储设备的层级结构">存储设备的层级结构</h3><p>寄存器 -&gt; L1高速缓存（SRAM） -&gt; L2高速缓存（SRAM） -&gt; L3高速缓存（SRAM） -&gt; 主存（DRAM）-&gt; 本地二级存储（磁盘） -&gt; 远程二级存储（分布式，Web）。</p>
<h2 id="操作系统">操作系统</h2><p>在hello程序中我们并没有直接调用键盘，显示器等，这些其实都是由操作系统完成的，在应用程序和硬件之间。操作系统有两个基本功能：</p>
<ul>
<li>防止硬件被滥用。</li>
<li>向应用提供简单一致的控制硬件机制。</li>
</ul>
<p>总的来说，文件是对I/O设备的抽象，虚拟存储器是对主存和磁盘I/O的抽象，进程则是对处理器，主存和磁盘I/O的抽象。</p>
<h3 id="进程和线程">进程和线程</h3><p>进程是操作系统对一个正在运行程序的抽象，无论是在单核，还是多核系统中，一个CPU看上去都像在并发的执行多个进程，这是通过处理器在进程间切换实现的，这种交错机制也称为上下文切换。</p>
<p>通常情况下一个进程只有单一的控制流，但是现代系统中，一个线程实际上可以由多个线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样地代码和全局数据。</p>
<h3 id="虚拟存储器">虚拟存储器</h3><p>这是一个抽象的概念，为进程提供一个假象，好似每个进程都在独占整个主存。每个进程看到的都是一致的存储器，称为虚拟地址空间。</p>
<ul>
<li>程序代码和数据 （对于所有的进程来说，代码是从一个固定的地址开始的，紧接着是C全局变量相对应的数据位置。</li>
<li>堆     （运行时使用的堆，代码和数据区在刚开始运行已经被设定好大小，而堆是动态分配的）</li>
<li>共享库 （大致是放一些C标准库，数学库这样的共享库的代码和数据区）</li>
<li>栈     （位于虚拟地址空间顶部，编译器用来实现函数调用，可以动态扩展和收缩）</li>
<li>内核虚拟存储器 （内核总是驻留在内存中，顶部空间是为内核预留的）</li>
</ul>
<h3 id="文件">文件</h3><p>文件就是字节序列，每个I/O设备都可以看成文件，向应用程序提供了一个统一的视角。</p>
<h2 id="重要主题">重要主题</h2><h3 id="网络通信">网络通信</h3><p>前面我们都是孤立的看待系统，分为硬件和软件，实际上在现代系统中已经离不开网络的存在。从一个单独的系统来看，网络可以视为一个I/O设备，通过一个网络适配器，系统可以读取其他机器发来的数据。</p>
<h3 id="并发和并行">并发和并行</h3><pre><code>-<span class="ruby"> 线程级并发 （可以使应用程序更快，可以并行地高效执行）
</span>
-<span class="ruby"> 指令级并行 （处理器可以同时执行多条指令的属性称为指令级并行）
</span>
-<span class="ruby"> 单指令，多数据并行 （允许一条指令产生多个可以并行执行的操作）</span>
</code></pre><h3 id="计算机系统中抽象的重要性">计算机系统中抽象的重要性</h3><p>无需了解内部实现可以使用，前面介绍了三种抽象，再往外扩展，虚拟机则是对整个计算机（操作系统，处理器，程序）的抽象。</p>
<h2 id="总结">总结</h2><ol>
<li><p>计算机系统是由硬件和软件组成，共同协作运行程序，内部信息通过位表示，根据不同的上下文解释不同，经过编译系统翻译成可执行文件。</p>
</li>
<li><p>处理器读取并解释在主存中的二进制指令，由于大量时间花费在数据传输中，所以引入缓存机制，存储结构分级。</p>
</li>
<li><p>操作系统内核是应用程序和硬件的媒介，提供了三种抽象：文件，虚拟存储器和进程。</p>
</li>
<li><p>最后网络提供了计算机之间通信的手段，换个角度看，网络也是一种I/O。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>计算机系统是由硬件+软件构成，共同工作来运行应用程序。这里由一个非常简单的例子入手观察在整个程序生命周期中，计算机系统分别承担了什么样的责任。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio,h&gt;</span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="built_in">printf</span>(<span class="string">"hello, world"</span>);
}
</code></pre><h2 id="系统简介">系统简介</h2><h3 id="信息就是位+上下文">信息就是位+上下文</h3><p>这是一个很简单的C语言源程序，在计算机系统中，像这样的源程序一般都是由ASCⅡ字符构成，也称为文本文件，其他文件则称为二进制文件。这也透露出来一个基本的理念：系统中所有的信息（磁盘上，存储器中，网络中）都是由一串位表示的，唯一区别只是上下文。</p>]]>
    
    </summary>
    
      <category term="CS" scheme="http://blog.tracyone.com/tags/CS/"/>
    
      <category term="Computer System" scheme="http://blog.tracyone.com/categories/Computer-System/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出ARC(下)]]></title>
    <link href="http://blog.tracyone.com/2015/06/16/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAARC-%E4%B8%8B/"/>
    <id>http://blog.tracyone.com/2015/06/16/深入浅出ARC-下/</id>
    <published>2015-06-16T14:24:52.000Z</published>
    <updated>2015-06-20T02:56:36.000Z</updated>
    <content type="html"><![CDATA[<p>终于到最后一篇了，前面两篇几乎没有涉及到ARC，全是内存管理，这一次要好好研究一下ARC的底层实现，在看的过程中感觉以前学得C++忘的差不多了。这一篇主要讲ARC的<strong>strong,</strong>weak,__autorelease修饰符背后发生了什么。</p>
<h3 id="__strong">__strong</h3><p>找了很多资料，发现还是书上的解释比较靠谱，在strong类型对象超出作用域后会调用objc_release函数，当然在属性为strong的情况下赋值是会走这个方法objc_storeStrong，这个也是比较标准的setter方法的写法。<br><a id="more"></a><br>1.先取得原先的对象，然后和新的对象比较，如果是同一个则直接返回，然后对新的对象retain，赋给老得对象，然后再release老的对象，来保证赋值给strong类型的属性时可以正常的retainCount+1.</p>
<pre><code>void
objc_storeStrong<span class="list">(<span class="keyword">id</span> <span class="variable">*location, id obj)
{
    id prev = *</span>location<span class="comment">;</span>
    if <span class="list">(<span class="keyword">obj</span> == prev)</span> {
        return<span class="comment">;</span>
    }
    objc_retain<span class="list">(<span class="keyword">obj</span>)</span><span class="comment">;</span>
    <span class="variable">*location = obj;
    objc_release(prev);
}</span></span>
</code></pre><h3 id="__strong中的autorelease">__strong中的autorelease</h3><p>对于一个非持有对象赋值给strong类型的变量时，编译器会插入两个比较有意思的函数,这两个函数可以极大减少开销，减轻autoreleasePool的负担。</p>
<p>1.两个函数都会做一个校验，看是否能够不加入autoreleasePool，直接返回对象。</p>
<pre><code><span class="property">id</span> 
objc_autoreleaseReturnValue(<span class="property">id</span> obj)
{
    <span class="keyword">if</span> (fastAutoreleaseForReturn(obj)) <span class="constant">return</span> obj;
<span class="command">
    return</span> objc_autorelease(obj);
}

<span class="property">id</span>
objc_retainAutoreleasedReturnValue(<span class="property">id</span> obj)
{
    <span class="keyword">if</span> (fastRetainFromReturn(obj)) <span class="constant">return</span> obj;
<span class="command">
    return</span> objc_retain(obj);
}
</code></pre><p>2.这两个函数则是揭秘了如何做到不加入autereleasePool而延长生命周期的，具体并没有看太懂，貌似是和线程有关，通过线程的内存中转一下。看了一下，不同的cpu架构实现方式都不同。</p>
<pre><code><span class="keyword">static</span> ALWAYS_INLINE 
<span class="keyword">bool</span> fastAutoreleaseForReturn(<span class="keyword">id</span> obj)
{
    assert(tls_get_direct(AUTORELEASE_POOL_RECLAIM_KEY) == <span class="literal">nil</span>);

    <span class="keyword">if</span> (callerAcceptsFastAutorelease(__builtin_return_address(<span class="number">0</span>))) {
        tls_set_direct(AUTORELEASE_POOL_RECLAIM_KEY, obj);
        <span class="keyword">return</span> <span class="literal">true</span>;
    }

    <span class="keyword">return</span> <span class="literal">false</span>;
}


<span class="keyword">static</span> ALWAYS_INLINE
<span class="keyword">bool</span> fastRetainFromReturn(<span class="keyword">id</span> obj)
{
    <span class="keyword">if</span> (obj == tls_get_direct(AUTORELEASE_POOL_RECLAIM_KEY)) {
        tls_set_direct(AUTORELEASE_POOL_RECLAIM_KEY, <span class="number">0</span>);
        <span class="keyword">return</span> <span class="literal">true</span>;
    }

    <span class="keyword">return</span> <span class="literal">false</span>;
}
</code></pre><h3 id="__weak">__weak</h3><p>赋值给weak类型变量的对象主要会经过这几步</p>
<p>1.编译器增加objc_initWeak函数调用，然后会调用objc_storeWeak函数。</p>
<pre><code>id
objc_initWeak(id *addr, id <span class="function"><span class="keyword">val</span>)
</span>{
    *addr = <span class="number">0</span>;
    <span class="keyword">if</span> (!<span class="function"><span class="keyword">val</span>) <span class="title">return</span> <span class="title">nil</span>;</span>
    <span class="keyword">return</span> objc_storeWeak(addr, <span class="function"><span class="keyword">val</span>);</span>
}
</code></pre><p>2.这个函数看上去做了很多事，其实很多都可以略过不看，主要做了通过weak_unregister_no_lock函数把原来的对象unregister，通过weak_register_no_lock函数把新的对象register进去。最后一步就是通过setWeaklyReferenced_nolock函数使得引用计数那张散列表的weak引用对象的引用计数中标识为weak引用。</p>
<pre><code><span class="function">id
<span class="title">objc_storeWeak</span><span class="params">(id *location, id newObj)</span>
</span>{
    id oldObj;
    SideTable *oldTable;
    SideTable *newTable;
    <span class="keyword">spinlock_t</span> *lock1;
<span class="preprocessor">#<span class="keyword">if</span> SIDE_TABLE_STRIPE &gt; 1</span>
    <span class="keyword">spinlock_t</span> *lock2;
<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="comment">// Acquire locks for old and new values.</span>
    <span class="comment">// Order by lock address to prevent lock ordering problems. </span>
    <span class="comment">// Retry if the old value changes underneath us.</span>
 retry:
    oldObj = *location;

    oldTable = SideTable::tableForPointer(oldObj);
    newTable = SideTable::tableForPointer(newObj);

    lock1 = &amp;newTable-&gt;slock;
<span class="preprocessor">#<span class="keyword">if</span> SIDE_TABLE_STRIPE &gt; 1</span>
    lock2 = &amp;oldTable-&gt;slock;
    <span class="keyword">if</span> (lock1 &gt; lock2) {
        <span class="keyword">spinlock_t</span> *temp = lock1;
        lock1 = lock2;
        lock2 = temp;
    }
    <span class="keyword">if</span> (lock1 != lock2) spinlock_lock(lock2);
<span class="preprocessor">#<span class="keyword">endif</span></span>
    spinlock_lock(lock1);

    <span class="keyword">if</span> (*location != oldObj) {
        spinlock_unlock(lock1);
<span class="preprocessor">#<span class="keyword">if</span> SIDE_TABLE_STRIPE &gt; 1</span>
        <span class="keyword">if</span> (lock1 != lock2) spinlock_unlock(lock2);
<span class="preprocessor">#<span class="keyword">endif</span></span>
        <span class="keyword">goto</span> retry;
    }

    weak_unregister_no_lock(&amp;oldTable-&gt;<span class="keyword">weak_t</span>able, oldObj, location);
    newObj = weak_register_no_lock(&amp;newTable-&gt;<span class="keyword">weak_t</span>able, newObj, location);
    <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span>

    <span class="comment">// Set is-weakly-referenced bit in refcount table.</span>
    <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) {
        newObj-&gt;setWeaklyReferenced_nolock();
    }

    <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span>
    *location = newObj;

    spinlock_unlock(lock1);
<span class="preprocessor">#<span class="keyword">if</span> SIDE_TABLE_STRIPE &gt; 1</span>
    <span class="keyword">if</span> (lock1 != lock2) spinlock_unlock(lock2);
<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="keyword">return</span> newObj;
}
</code></pre><h3 id="__weak（没有证实的功能）">__weak（没有证实的功能）</h3><p>这里是书上看到的，同时也是在源码中能找到的，但是我却没有证实的一个知识点，就是使用了附有__weak修饰符的变量，会自动注册到autoreleasePool中。</p>
<p>1.不管是从注释还是代码，都证实了在使用weak变量时为了保证对象没有释放，会添加到autoreleasePool中</p>
<pre><code>/** 
 * This loads <span class="keyword">the</span> object referenced <span class="keyword">by</span> a weak pointer <span class="keyword">and</span> returns <span class="keyword">it</span>, <span class="keyword">after</span>
 * retaining <span class="keyword">and</span> autoreleasing <span class="keyword">the</span> object <span class="keyword">to</span> ensure <span class="keyword">that</span> <span class="keyword">it</span> stays alive
 * long enough <span class="keyword">for</span> <span class="keyword">the</span> caller <span class="keyword">to</span> use <span class="keyword">it</span>. This function would be used
 * anywhere a __weak variable <span class="keyword">is</span> used <span class="keyword">in</span> an expression.
 * 
 * @param location The weak pointer address
 * 
 * @<span class="constant">return</span> The object pointed <span class="keyword">to</span> <span class="keyword">by</span> \e location, <span class="keyword">or</span> \c nil <span class="keyword">if</span> \e location <span class="keyword">is</span> \c nil.
 */
<span class="property">id</span>
objc_loadWeak(<span class="property">id</span> *location)
{
    <span class="keyword">if</span> (!*location) <span class="constant">return</span> nil;
<span class="command">    return</span> objc_autorelease(objc_loadWeakRetained(location));
}
</code></pre><p>2.这里weak_read_no_lock函数会retain这个对象，然后通过外部autorelease。</p>
<pre><code>id
objc_loadWeakRetained(id *location)
{
    id <span class="literal">result</span>;

    <span class="type">SideTable</span> *table;
    spinlock_t *lock;

 retry:
    <span class="literal">result</span> = *location;
    <span class="keyword">if</span> (!<span class="literal">result</span>) <span class="keyword">return</span> <span class="keyword">nil</span>;

    table = <span class="type">SideTable</span>::tableForPointer(<span class="literal">result</span>);
    lock = &amp;table-&gt;slock;

    spinlock_lock(lock);
    <span class="keyword">if</span> (*location != <span class="literal">result</span>) {
        spinlock_unlock(lock);
        goto retry;
    }

    <span class="literal">result</span> = weak_read_no_lock(&amp;table-&gt;weak_table, location);

    spinlock_unlock(lock);
    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>由此可知正在使用的weak变量不会被释放，但是如果大量使用weak变量会造成autoreleasePool中得对象大量增加，所以我们需要找到一个平衡点。</p>
<h3 id="__autorelease">__autorelease</h3><p>这个修饰符很少用，等同于ARC无效时调用autorelease方法，一般可以配合@autorelease使用来达到减少瞬时内存峰值。</p>
<p>ARC到这里也告一段落了，回过头来发现在这一段学习的过程中有一种豁然开朗的感觉，以前可能大概知道一点内存管理，但总是有一些点不能理解，在学习的道路上又进了一步。下一次准备看一下GCD那一块的知识，也算是对这本书的一个交代。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>终于到最后一篇了，前面两篇几乎没有涉及到ARC，全是内存管理，这一次要好好研究一下ARC的底层实现，在看的过程中感觉以前学得C++忘的差不多了。这一篇主要讲ARC的<strong>strong,</strong>weak,__autorelease修饰符背后发生了什么。</p>
<h3 id="__strong">__strong</h3><p>找了很多资料，发现还是书上的解释比较靠谱，在strong类型对象超出作用域后会调用objc_release函数，当然在属性为strong的情况下赋值是会走这个方法objc_storeStrong，这个也是比较标准的setter方法的写法。<br>]]>
    
    </summary>
    
      <category term="ARC" scheme="http://blog.tracyone.com/tags/ARC/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出ARC(中)]]></title>
    <link href="http://blog.tracyone.com/2015/06/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAARC-%E4%B8%AD/"/>
    <id>http://blog.tracyone.com/2015/06/15/深入浅出ARC-中/</id>
    <published>2015-06-15T14:28:03.000Z</published>
    <updated>2015-06-20T02:57:16.000Z</updated>
    <content type="html"><![CDATA[<p>这篇主要探究一下dealloc额外做的两三事，autorelease的内幕，以及ARC的使用规则。本来不准备写dealloc和autorelease的，不过昨天在看源码的时候发现还是很有意思的，然后也是为了内存管理的完整性，就顺带着记录下来了。</p>
<h2 id="dealloc搞得鬼">dealloc搞得鬼</h2><p>上一次看到这里发现了一个objc_destructInstance函数的调用，这次主要就是探究下，这个函数做了什么。<br><a id="more"></a></p>
<pre><code><span class="function">id 
<span class="title">object_dispose</span><span class="params">(id obj)</span>
</span>{
    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;
    objc_destructInstance(obj);    
<span class="preprocessor">#<span class="keyword">if</span> SUPPORT_GC</span>
    <span class="keyword">if</span> (UseGC) {
        auto_zone_retain(gc_zone, obj); <span class="comment">// gc free expects rc==1</span>
    }
<span class="preprocessor">#<span class="keyword">endif</span></span>
    <span class="built_in">free</span>(obj);
    <span class="keyword">return</span> nil;
}
</code></pre><p>在这里大致做了三件事，调用c++ destructors，移除关联对象，清理散列表中得一些值。</p>
<pre><code>void <span class="built_in">*</span>objc_destructInstance<span class="params">(id obj)</span> 
{
    <span class="keyword">if</span> <span class="params">(obj)</span> {
        <span class="comment">// Read all of the flags at once for performance.</span>
        bool cxx = obj-&gt;hasCxxDtor<span class="params">()</span>;
        bool assoc = <span class="built_in">!</span>UseGC &amp;&amp; obj-&gt;hasAssociatedObjects<span class="params">()</span>;
        bool dealloc = <span class="built_in">!</span>UseGC;

        <span class="comment">// This order is important.</span>
        <span class="keyword">if</span> <span class="params">(cxx)</span> object_cxxDestruct<span class="params">(obj)</span>;
        <span class="keyword">if</span> <span class="params">(assoc)</span> _object_remove_assocations<span class="params">(obj)</span>;
        <span class="keyword">if</span> <span class="params">(dealloc)</span> obj-&gt;clearDeallocating<span class="params">()</span>;
    }
    return obj;
}
</code></pre><h3 id="destructors">destructors</h3><p>1.从名字上看能大概看出是一个c++的析构函数，如果不是isTaggedPointer则调用object_cxxDestructFromClass这个析构函数</p>
<pre><code>void object_cxxDestruct<span class="params">(id obj)</span>
{
    <span class="keyword">if</span> <span class="params">(!obj)</span> return;
    <span class="keyword">if</span> <span class="params">(obj-&gt;isTaggedPointer<span class="params">()</span>)</span> return;
    object_cxxDestructFromClass<span class="params">(obj, obj-&gt;ISA<span class="params">()</span>)</span>;
}
</code></pre><p>2.这里关键就是取到真正的析构函数，所以用了个函数指针，因为需要做一系列的判断，最后调用lookupMethodInClassAndLoadCache函数。</p>
<pre><code>static void object_cxxDestructFromClass<span class="params">(id obj, Class cls)</span>
{
    void <span class="params">(*dtor)</span><span class="params">(id)</span>;

    <span class="comment">// Call cls's dtor first, then superclasses's dtors.</span>

    <span class="keyword">for</span> <span class="params">( ; cls; cls = cls-&gt;superclass)</span> {
        <span class="keyword">if</span> <span class="params">(!cls-&gt;hasCxxDtor<span class="params">()</span>)</span> return; 
        dtor = <span class="params">(void<span class="params">(*)</span><span class="params">(id)</span>)</span>
            lookupMethodInClassAndLoadCache<span class="params">(cls, SEL_cxx_destruct)</span>;
        <span class="keyword">if</span> <span class="params">(dtor != <span class="params">(void<span class="params">(*)</span><span class="params">(id)</span>)</span>_objc_msgForward_impcache)</span> {
            <span class="keyword">if</span> <span class="params">(PrintCxxCtors)</span> {
                _objc_inform<span class="params">(<span class="string">"CXX: calling C++ destructors for class %s"</span>, 
                             cls-&gt;nameForLogging<span class="params">()</span>)</span>;
            }
            <span class="params">(*dtor)</span><span class="params">(obj)</span>;
        }
    }
}
</code></pre><p>3.这个就是查找析构函数的函数，先从缓存表中找，再从方法列表中找，如果找到还要放到缓存表中，找不到的话就调用方法转发，并且缓存起来。</p>
<pre><code><span class="type">IMP</span> lookupMethodInClassAndLoadCache(<span class="type">Class</span> cls, <span class="type">SEL</span> sel)
{
    <span class="type">Method</span> meth;
    <span class="type">IMP</span> imp;

    // fixme this <span class="keyword">is</span> incomplete - no resolver, +initialize, <span class="type">GC</span> - 
    // but it's only used <span class="keyword">for</span> .cxx_construct/destruct so we don't care
    assert(sel == <span class="type">SEL_cxx_construct</span>  ||  sel == <span class="type">SEL_cxx_destruct</span>);

    // <span class="type">Search</span> cache first.
    imp = cache_getImp(cls, sel);
    <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;

    // <span class="type">Cache</span> miss. <span class="type">Search</span> <span class="keyword">method</span> list.

    rwlock_read(&amp;runtimeLock);

    meth = getMethodNoSuper_nolock(cls, sel);

    <span class="keyword">if</span> (meth) {
        // <span class="type">Hit</span> <span class="keyword">in</span> <span class="keyword">method</span> list. <span class="type">Cache</span> it.
        cache_fill(cls, sel, meth-&gt;imp);
        rwlock_unlock_read(&amp;runtimeLock);
        <span class="keyword">return</span> meth-&gt;imp;
    } <span class="keyword">else</span> {
        // <span class="type">Miss</span> <span class="keyword">in</span> <span class="keyword">method</span> list. <span class="type">Cache</span> objc_msgForward.
        cache_fill(cls, sel, _objc_msgForward_impcache);
        rwlock_unlock_read(&amp;runtimeLock);
        <span class="keyword">return</span> _objc_msgForward_impcache;
    }
}
</code></pre><h3 id="关联对象">关联对象</h3><p>关联对象我记得之前有个大神讲过，看的有点迷糊，就自己翻了下源码，主要就一个函数，大致思路就是关联对象会存在一张映射表中，根据传入的object找到关联对象映射表，遍历映射表添加到vector中，然后最后清楚相关数据，最后的时候遍历vector，release关联对象。</p>
<pre><code>void _object_remove_assocations<span class="params">(id object)</span> {
    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations<span class="params">(manager.associations<span class="params">()</span>)</span>;
        <span class="keyword">if</span> <span class="params">(associations.size<span class="params">()</span> == <span class="number">0</span>)</span> return;
        disguised_ptr_t disguised_object = DISGUISE<span class="params">(object)</span>;
        AssociationsHashMap::iterator i = associations.find<span class="params">(disguised_object)</span>;
        <span class="keyword">if</span> <span class="params">(i != associations.end<span class="params">()</span>)</span> {
            <span class="comment">// copy all of the associations that need to be removed.</span>
            ObjectAssociationMap <span class="built_in">*</span>refs = i-&gt;second;
            <span class="keyword">for</span> <span class="params">(ObjectAssociationMap::iterator j = refs-&gt;begin<span class="params">()</span>, end = refs-&gt;end<span class="params">()</span>; j != end; ++j)</span> {
                elements.push_back<span class="params">(j-&gt;second)</span>;
            }
            <span class="comment">// remove the secondary table.</span>
            delete refs;
            associations.erase<span class="params">(i)</span>;
        }
    }
    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span>
    for_each<span class="params">(elements.begin<span class="params">()</span>, elements.end<span class="params">()</span>, ReleaseValue<span class="params">()</span>)</span>;
}
</code></pre><h3 id="clearDeallocating">clearDeallocating</h3><p>这里做的主要是清理weak变量，具体内容可以参考<a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/" target="_blank" rel="external">sunny大神的博客</a></p>
<pre><code><span class="tag">inline</span> <span class="tag">void</span> 
<span class="rule"><span class="attribute">objc_object</span>:<span class="value">:<span class="function">clearDeallocating</span>()
{
    <span class="function">sidetable_clearDeallocating</span>()</span></span>;
}
</code></pre><p>2.还是取散列表SideTable，遍历是否有weak引用，it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED这里用到的就是前面所说的宏，作用就是标示是否有weak引用。如果有就调用weak_clear_no_lock这个函数，这个函数中会遍历清除所有weak引用，这就是Objc不需要我们手动清理weak引用的关键点。</p>
<pre><code><span class="literal">void</span> 
objc_object<span class="tag">::sidetable_clearDeallocating</span>()
{
    SideTable <span class="subst">*</span>table <span class="subst">=</span> SideTable<span class="tag">::tableForPointer</span>(this);

    <span class="comment">// clear any weak table items</span>
    <span class="comment">// clear extra retain count and deallocating bit</span>
    <span class="comment">// (<span class="doctag"><span class="keyword">fixme</span></span> warn or abort if extra retain count == 0 ?)</span>
    spinlock_lock(<span class="subst">&amp;</span>table<span class="subst">-&gt;</span>slock);
    RefcountMap<span class="tag">::iterator</span> it <span class="subst">=</span> table<span class="subst">-&gt;</span>refcnts<span class="built_in">.</span>find(this);
    <span class="keyword">if</span> (it <span class="subst">!=</span> table<span class="subst">-&gt;</span>refcnts<span class="built_in">.</span>end()) {
        <span class="keyword">if</span> (it<span class="subst">-&gt;</span>second <span class="subst">&amp;</span> SIDE_TABLE_WEAKLY_REFERENCED) {
            weak_clear_no_lock(<span class="subst">&amp;</span>table<span class="subst">-&gt;</span>weak_table, (id)this);
        }
        table<span class="subst">-&gt;</span>refcnts<span class="built_in">.</span>erase(it);
    }
    spinlock_unlock(<span class="subst">&amp;</span>table<span class="subst">-&gt;</span>slock);
}
</code></pre><h2 id="autorelease的内幕">autorelease的内幕</h2><p>这个专题基本讲烂了，先上几篇我参考的优质博客<br><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">sunnyxx的《黑幕背后的Autorelease》</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">雷纯锋的《Objective-C Autorelease Pool 的实现原理》</a></p>
<p>大神们已经讲的很详细了，不过为了内容的完整，还是硬着头皮自己去理一下逻辑，写一点不一样的东西，所以下面并不会去探究autoreleasePool实现原理，只看NSObject中autorelease函数的实现。</p>
<h3 id="autorelease函数做了什么">autorelease函数做了什么</h3><p>1.前面两步都是简单调用底层函数，最终调用的是rootAutorelease2函数</p>
<pre><code>- (<span class="keyword">id</span>)autorelease {
    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootAutorelease();
}

<span class="keyword">inline</span> <span class="keyword">id</span> 
objc_object::rootAutorelease()
{
    assert(!UseGC);

    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;
    <span class="keyword">if</span> (fastAutoreleaseForReturn((<span class="keyword">id</span>)<span class="keyword">this</span>)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;

    <span class="keyword">return</span> rootAutorelease2();
}
</code></pre><p>3.这一步会调用AutoreleasePoolPage的autorelease函数，关于AutoreleasePoolPage的实现可以看上面两位大神的讲解。</p>
<pre><code>__<span class="tag">attribute__</span>((<span class="tag">noinline</span>,<span class="tag">used</span>))
<span class="tag">id</span> 
<span class="rule"><span class="attribute">objc_object</span>:<span class="value">:<span class="function">rootAutorelease2</span>()
{
    <span class="function">assert</span>(!<span class="function">isTaggedPointer</span>())</span></span>;
    <span class="tag">return</span> <span class="rule"><span class="attribute">AutoreleasePoolPage</span>:<span class="value">:<span class="function">autorelease</span>((id)this)</span></span>;
}
</code></pre><p>4.这两步都是AutoreleasePoolPage的方法，主要就是判断当前page是否已满，如果没有就直接add，如果已经满了则会去重新new一个page，然后设为当前页，并且添加进去，如果当前没有page，则会初始化第一个page然后添加。</p>
<pre><code>static inline id autorelease<span class="params">(id obj)</span>
    {
        assert<span class="params">(obj)</span>;
        assert<span class="params">(!obj-&gt;isTaggedPointer<span class="params">()</span>)</span>;
        id <span class="built_in">*</span>dest __unused = autoreleaseFast<span class="params">(obj)</span>;
        assert<span class="params">(!dest  ||  *dest == obj)</span>;
        return obj;
    }

static inline id <span class="built_in">*</span>autoreleaseFast<span class="params">(id obj)</span>
    {
        AutoreleasePoolPage <span class="built_in">*</span>page = hotPage<span class="params">()</span>;
        <span class="keyword">if</span> <span class="params">(page &amp;&amp; !page-&gt;full<span class="params">()</span>)</span> {
            return page-&gt;add<span class="params">(obj)</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(page)</span> {
            return autoreleaseFullPage<span class="params">(obj, page)</span>;
        } <span class="keyword">else</span> {
            return autoreleaseNoPage<span class="params">(obj)</span>;
        }
    }
</code></pre><h2 id="ARC使用原则">ARC使用原则</h2><h3 id="修饰符">修饰符</h3><p>其实这些东西都是老掉牙的内容了，我就简单说几点吧。这些不是关键，同样是为了内容完整性考虑。</p>
<ul>
<li>__strong 这个就是代表了强引用，在超出作用域的时候会release一下，大多数情况下strong已经能够保证内存管理正确了。</li>
<li>__weak 这个就是用来处理那些strong解决不了的情况，循环引用。只能在iOS5以上使用</li>
<li>__unsafe_unretain 这个就意味着不属于编译器的内存管理，如果指向的对象已经释放，野指针。</li>
<li>__autoreleasing 这个东西几乎很少用，因为大多数时间编译器知道哪些变量是需要autoreleasing。比如说在取得非自己持有的对象时，该对象自动被加入autoreleasing pool。再比如说访问id* 类型的变量。</li>
</ul>
<p>每个id类型的对象必须有一种修饰符，在ARC下，其中__strong是默认的修饰符。除了unsafe_unretain，其余的可以保证初始化为nil。</p>
<h3 id="规则">规则</h3><ol>
<li>不能使用retain/release/retainCount/autorelease。</li>
<li>不能使用NSAllocateObject/NSDeallocateObject。</li>
<li>必须遵守内存管理的命名规则。</li>
<li>不能显示的调用dealloc，比如[super dealloc]。</li>
<li>用@autorelease代替NSAutoreleasePool。</li>
<li>不能使用NSZone。</li>
<li>对象类型变量不能作为C语言结构体成员（可以用__unsafe_unretain修饰之后使用）</li>
<li>不能显示转换id和void*（可以通过<em>_bridge,\</em>_bridge_retained,__bridge_transfer）。</li>
</ol>
<p>这些都是书上有的，基本很全了。</p>
<h2 id="萌萌的小尾巴">萌萌的小尾巴</h2><p>到此ARC内存管理这一块讲了很多了，还剩下ARC具体实现了，这个放到下面一篇分析，ARC是由编译器来管理内存了，但实际上单纯靠编译器是实现不了的，还需要runtime来辅助。所以实际上ARC使用了Clang和Objc库来完成内存管理的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇主要探究一下dealloc额外做的两三事，autorelease的内幕，以及ARC的使用规则。本来不准备写dealloc和autorelease的，不过昨天在看源码的时候发现还是很有意思的，然后也是为了内存管理的完整性，就顺带着记录下来了。</p>
<h2 id="dealloc搞得鬼">dealloc搞得鬼</h2><p>上一次看到这里发现了一个objc_destructInstance函数的调用，这次主要就是探究下，这个函数做了什么。<br>]]>
    
    </summary>
    
      <category term="ARC" scheme="http://blog.tracyone.com/tags/ARC/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出ARC(上)]]></title>
    <link href="http://blog.tracyone.com/2015/06/14/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAARC-%E4%B8%8A/"/>
    <id>http://blog.tracyone.com/2015/06/14/深入浅出ARC-上/</id>
    <published>2015-06-14T15:14:12.000Z</published>
    <updated>2015-06-20T02:57:17.000Z</updated>
    <content type="html"><![CDATA[<p>最近和同事在讨论一个循环引用问题的时候，不经意间讨论到了内存管理的本质到底是什么，于是翻出《Objective-C高级编程》一看，但是发现上面有些问题，可能是比较旧了，苹果有了新的实现，所以拿出Objc源码研究了下，下面是自己研究的内容，如果理解有误，请定要联系我纠正。</p>
<h3 id="内存管理">内存管理</h3><p>大家都知道，Objc是通过引用计数来管理内存的（Mac除外啊，毕竟处理器牛逼），主要就遵循以下几个原则：</p>
<ol>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要持有的对象，自己可以释放。</li>
<li>非自己持有的对象不能释放。</li>
</ol>
<p>其实这些就是对应了Objc中得alloc，retain等方法，这些是引用计数的思考方式，并不因是否ARC改变，那么接下来看一下一些底层实现。</p>
<a id="more"></a>
<h3 id="alloc">alloc</h3><p>通过苹果官网开源的Objc库，我们可以发现总共调用了如下几个方法，虽然很长，然而有一些我们是可以忽略的，逐步分析。</p>
<p>1.这个方法很简单就是调用了_objc_rootAlloc函数。</p>
<pre><code>+ (<span class="keyword">id</span>)alloc {
    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);
}
</code></pre><p>2.调用了callAlloc函数，这个函数有三个参数，其中第一个参数不能为空，这是一个最基础的alloc方法的实现。</p>
<pre><code>id
_objc_rootAlloc(<span class="class"><span class="keyword">Class</span> <span class="title">cls</span>)
</span>{
    <span class="keyword">return</span> callAlloc(cls, <span class="keyword">false</span><span class="comment">/*checkNil*/</span>, <span class="keyword">true</span><span class="comment">/*allocWithZone*/</span>);
}
</code></pre><p>3.这里调用的代码就变多了，其实大部分都不需要看，关键就在class_createInstance上，这也是真实地创建实例的方法。其他代码主要是去判断是否自定义alloc等。</p>
<pre><code><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span>
callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)
{
    <span class="keyword">if</span> (checkNil &amp;&amp; !cls) <span class="keyword">return</span> <span class="literal">nil</span>;
\<span class="preprocessor">#if __OBJC2__</span>
    <span class="keyword">if</span> (! cls-&gt;ISA()-&gt;hasCustomAWZ()) {
        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span>
        <span class="comment">// <span class="doctag"><span class="keyword">fixme</span></span> store hasCustomAWZ in the non-meta class and </span>
        <span class="comment">// add it to canAllocFast's summary</span>
        <span class="keyword">if</span> (cls-&gt;canAllocFast()) {
            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span>
            <span class="keyword">bool</span> dtor = cls-&gt;hasCxxDtor();
            <span class="keyword">id</span> obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, cls-&gt;bits<span class="variable">.fastInstanceSize</span>());
            <span class="keyword">if</span> (!obj) <span class="keyword">return</span> callBadAllocHandler(cls);
            obj-&gt;initInstanceIsa(cls, dtor);
            <span class="keyword">return</span> obj;
        }
        <span class="keyword">else</span> {
            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span>
            <span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);
            <span class="keyword">if</span> (!obj) <span class="keyword">return</span> callBadAllocHandler(cls);
            <span class="keyword">return</span> obj;
        }
    }
<span class="preprocessor">#endif</span>

    <span class="comment">// No shortcuts available.</span>
    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:<span class="literal">nil</span>];
    <span class="keyword">return</span> [cls alloc];
}
</code></pre><p>4.这个函数则是调用了一个私有函数_class_createInstanceFromZone，从这里也能看出Objc其实已经不用zone了。</p>
<pre><code>id 
<span class="keyword">class</span><span class="number">_</span>createInstance(Class cls, size<span class="number">_</span>t extraBytes)
{
    <span class="keyword">return</span> <span class="number">_</span><span class="keyword">class</span><span class="number">_</span>createInstanceFromZone(cls, extraBytes, nil);
}
</code></pre><p>5.最终调用的其实是这一行代码obj = (id)calloc(1, size);到这里一个对象的初始化基本告一段落了，这中间跳过了很多，不过这次主要是探究一下和内存管理相关的，也无伤大雅。最后是用calloc分配了一个初始化为0的对象。</p>
<pre><code>static __attribute__<span class="params">(<span class="params">(always_inline)</span>)</span> 
id
_class_createInstanceFromZone<span class="params">(Class cls, size_t extraBytes, void *zone)</span>
{
    <span class="keyword">if</span> <span class="params">(!cls)</span> return nil;

    assert<span class="params">(cls-&gt;isRealized<span class="params">()</span>)</span>;

    <span class="comment">// Read class's info bits all at once for performance</span>
    bool hasCxxCtor = cls-&gt;hasCxxCtor<span class="params">()</span>;
    bool hasCxxDtor = cls-&gt;hasCxxDtor<span class="params">()</span>;
    bool fast = cls-&gt;canAllocIndexed<span class="params">()</span>;

    size_t size = cls-&gt;instanceSize<span class="params">(extraBytes)</span>;

    id obj;
    <span class="keyword">if</span> <span class="params">(!UseGC  &amp;&amp;  !zone  &amp;&amp;  fast)</span> {
        obj = <span class="params">(id)</span>calloc<span class="params">(<span class="number">1</span>, size)</span>;
        <span class="keyword">if</span> <span class="params">(!obj)</span> return nil;
        obj-&gt;initInstanceIsa<span class="params">(cls, hasCxxDtor)</span>;
    } 
    <span class="keyword">else</span> {
<span class="built_in">#</span><span class="keyword">if</span> SUPPORT_GC
        <span class="keyword">if</span> <span class="params">(UseGC)</span> {
            obj = <span class="params">(id)</span>auto_zone_allocate_object<span class="params">(gc_zone, size,
                                                AUTO_OBJECT_SCANNED, <span class="number">0</span>, <span class="number">1</span>)</span>;
        } <span class="keyword">else</span> 
<span class="built_in">#</span>endif
        <span class="keyword">if</span> <span class="params">(zone)</span> {
            obj = <span class="params">(id)</span>malloc_zone_calloc <span class="params">(<span class="params">(malloc_zone_t *)</span>zone, <span class="number">1</span>, size)</span>;
    } <span class="keyword">else</span> {
            obj = <span class="params">(id)</span>calloc<span class="params">(<span class="number">1</span>, size)</span>;
        }
        <span class="keyword">if</span> <span class="params">(!obj)</span> return nil;

        <span class="comment">// Use non-indexed isa on the assumption that they might be </span>
        <span class="comment">// doing something weird with the zone or RR.</span>
        obj-&gt;initIsa<span class="params">(cls)</span>;
    }

    <span class="keyword">if</span> <span class="params">(hasCxxCtor)</span> {
        obj = _objc_constructOrFree<span class="params">(obj, cls)</span>;
    }

    return obj;
}
</code></pre><h3 id="retianCount">retianCount</h3><p>前面可能大家会很奇怪，为什么没有看到初始化为1的retainCount呢？其实这和Objc的retainCount实现原理有关，下面上源码：</p>
<p>1.这个方法很简单就是调用了rootRetainCount这个函数</p>
<pre><code>- (NSUInteger)retainCount {
    <span class="keyword">return</span> <span class="function"><span class="params">((id)self)</span>-&gt;</span>rootRetainCount();
}
</code></pre><p>2.这里有一个是否isTaggedPointer的判断，相关内容可以查看唐巧的<a href="http://www.devtang.com/blog/2014/05/30/understand-tagged-pointer/" target="_blank" rel="external">这篇博客</a>。这个可以跳过，主要就是调用了sidetable_retainCount这个函数。</p>
<pre><code><span class="keyword">inline</span> <span class="keyword">uintptr_t</span> 
objc_object::rootRetainCount()
{
    assert(!UseGC);
    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)<span class="keyword">this</span>;
    <span class="keyword">return</span> sidetable_retainCount();
}
</code></pre><p>3.从名字上看这应该是一个和sidetable相关的函数，果然，里面使用了SideTable，从这里，我们大致可以看出Objc使用了类似散列表的结构来记录引用计数。并且在初始化的时候设为了一。不过在这里有一个很奇怪的点，为什么最后返回的refcnt_result是1加上it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT。这个也是苹果机智的地方，等下会介绍。</p>
<pre><code>uintptr_t
objc_object::sidetable_retainCount()
{
    <span class="type">SideTable</span> *table = <span class="type">SideTable</span>::tableForPointer(this);

    size_t refcnt_result = <span class="number">1</span>;

    spinlock_lock(&amp;table-&gt;slock);
    <span class="type">RefcountMap</span>::<span class="keyword">iterator</span> it = table-&gt;refcnts.find(this);
    <span class="keyword">if</span> (it != table-&gt;refcnts.<span class="keyword">end</span>()) {
        // this <span class="keyword">is</span> valid <span class="keyword">for</span> <span class="type">SIDE_TABLE_RC_PINNED</span> too
        refcnt_result += it-&gt;second &gt;&gt; <span class="type">SIDE_TABLE_RC_SHIFT</span>;
    }
    spinlock_unlock(&amp;table-&gt;slock);
    <span class="keyword">return</span> refcnt_result;
}
</code></pre><h3 id="retain">retain</h3><p>这个就比较简单了，总结下来其实就是找到散列表中得retainCount然后加1向左偏移SIDE_TABLE_RC_SHIFT的值，这里可能大家就知道为什么上面要有一个偏移值了。</p>
<p>1.还是简单地调用了Objc中得rootRetain函数</p>
<pre><code>- (id)retain {
    <span class="keyword">return</span> <span class="function"><span class="params">((id)self)</span>-&gt;</span>rootRetain();
}
</code></pre><p>2.同样是判断是否isTaggedPointer，然后调用sidetable_retain。</p>
<pre><code>inline id 
objc_object::rootRetain()
{
    <span class="keyword">assert</span>(!UseGC);
    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;
    <span class="function"><span class="keyword">return</span> <span class="title">sidetable_retain</span><span class="params">()</span></span>;
}
</code></pre><p>3.同样地取到SideTable，refcntStorage += SIDE_TABLE_RC_ONE，同样地加了一个偏移量。然后也能看出散列表的key是对象的指针。</p>
<pre><code>id
objc_object::sidetable_retain()
{
<span class="preprocessor">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span>
    assert(!isa.indexed);
<span class="preprocessor">#<span class="keyword">endif</span></span>
    SideTable *table = SideTable::tableForPointer(<span class="keyword">this</span>);

    <span class="keyword">if</span> (<span class="keyword">spinlock_t</span>rylock(&amp;table-&gt;slock)) {
        <span class="keyword">size_t</span>&amp; refcntStorage = table-&gt;refcnts[<span class="keyword">this</span>];
        <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) {
            refcntStorage += SIDE_TABLE_RC_ONE;
        }
        spinlock_unlock(&amp;table-&gt;slock);
        <span class="keyword">return</span> (id)<span class="keyword">this</span>;
    }
    <span class="keyword">return</span> sidetable_retain_slow(table);
}
</code></pre><h3 id="release">release</h3><p>这里会解释SIDE_TABLE_RC_SHIFT这个偏移量存在的原因。前面两步和retain一样，不介绍了。</p>
<pre><code>- <span class="params">(oneway void)</span>release {
    <span class="params">(<span class="params">(id)</span>self)</span>-&gt;rootRelease<span class="params">()</span>;
}

inline bool 
objc_object::rootRelease<span class="params">()</span>
{
    assert<span class="params">(!UseGC)</span>;

    <span class="keyword">if</span> <span class="params">(isTaggedPointer<span class="params">()</span>)</span> return <span class="literal">false</span>;
    return sidetable_release<span class="params">(<span class="literal">true</span>)</span>;
}
</code></pre><p>3.主要看一下这里，其实加上SIDE_TABLE_RC_ONE这个偏移是为了空出SIDE_TABLE_DEALLOCATING这个标示，看下定义大家就能懂了</p>
<p>// The order of these bits is important.</p>
<ul>
<li>#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</li>
<li>#define SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  // MSB-ward of weak bit</li>
<li>#define SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  // MSB-ward of deallocating bit</li>
<li>#define SIDE_TABLE_RC_SHIFT 2</li>
</ul>
<p>4.SIDE_TABLE_WEAKLY_REFERENCED是代表了有弱引用，SIDE_TABLE_DEALLOCATING代表了需要释放的引用，SIDE_TABLE_RC_ONE这个则是正常的的偏移。值是和SIDE_TABLE_RC_SHIFT偏移一样的。<br>release比retain稍微复杂的地方就是他需要判断最终是否需要调用dealloc，所以多了很多判断和赋值，大概步骤就是1.先遍历变量是否存在，如果不存在就调用dealloc，2.如果存在再判断是否小于SIDE_TABLE_DEALLOCATING，如果成立同1，3.否则就减去一个SIDE_TABLE_RC_ONE4.最后看do_dealloc是否需要调用dealloc。</p>
<pre><code>bool 
objc_object::sidetable_release<span class="params">(bool performDealloc)</span>
{
\<span class="built_in">#</span><span class="keyword">if</span> SUPPORT_NONPOINTER_ISA
    assert<span class="params">(!isa.indexed)</span>;
\<span class="built_in">#</span>endif
    SideTable <span class="built_in">*</span>table = SideTable::tableForPointer<span class="params">(this)</span>;

    bool do_dealloc = <span class="literal">false</span>;

    <span class="keyword">if</span> <span class="params">(spinlock_trylock<span class="params">(&amp;table-&gt;slock)</span>)</span> {
        RefcountMap::iterator it = table-&gt;refcnts.find<span class="params">(this)</span>;
        <span class="keyword">if</span> <span class="params">(it == table-&gt;refcnts.end<span class="params">()</span>)</span> {
            do_dealloc = <span class="literal">true</span>;
            table-&gt;refcnts[this] = SIDE_TABLE_DEALLOCATING;
        } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(it-&gt;second &lt; SIDE_TABLE_DEALLOCATING)</span> {
            <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.</span>
            do_dealloc = <span class="literal">true</span>;
            it-&gt;second |= SIDE_TABLE_DEALLOCATING;
        } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(! <span class="params">(it-&gt;second &amp; SIDE_TABLE_RC_<span class="literal">PI</span>NNED)</span>)</span> {
            it-&gt;second -= SIDE_TABLE_RC_ONE;
        }
        spinlock_unlock<span class="params">(&amp;table-&gt;slock)</span>;
        <span class="keyword">if</span> <span class="params">(do_dealloc  &amp;&amp;  performDealloc)</span> {
            <span class="params">(<span class="params">(void<span class="params">(*)</span><span class="params">(objc_object *, SEL)</span>)</span>objc_msgSend)</span><span class="params">(this, SEL_dealloc)</span>;
        }
        return do_dealloc;
    }

    return sidetable_release_slow<span class="params">(table, performDealloc)</span>;
}
</code></pre><h3 id="dealloc">dealloc</h3><p>这里其实有很多细节的，比如说在dealloc的时候会做哪些操作等，这个放到下一次讲，这里主要看的是dealloc实现原理，前面3步很简单，略过。</p>
<pre><code>- <span class="params">(void)</span>dealloc {
    _objc_rootDealloc<span class="params">(self)</span>;
}

void
_objc_rootDealloc<span class="params">(id obj)</span>
{
    assert<span class="params">(obj)</span>;

    obj-&gt;rootDealloc<span class="params">()</span>;
}

inline void
objc_object::rootDealloc<span class="params">()</span>
{
    <span class="keyword">if</span> <span class="params">(isTaggedPointer<span class="params">()</span>)</span> return;
    object_dispose<span class="params">(<span class="params">(id)</span>this)</span>;
}
</code></pre><p>4.这里能够清晰地看到在dealloc之前其实会调用一下objc_destructInstance，这里面做了很多操作，清理关联对象，weak引用等，最后free掉。</p>
<pre><code><span class="function">id 
<span class="title">object_dispose</span><span class="params">(id obj)</span>
</span>{
    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;
    objc_destructInstance(obj);

\<span class="preprocessor">#<span class="keyword">if</span> SUPPORT_GC</span>
    <span class="keyword">if</span> (UseGC) {
        auto_zone_retain(gc_zone, obj); <span class="comment">// gc free expects rc==1</span>
    }
\<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="built_in">free</span>(obj);

    <span class="keyword">return</span> nil;
}
</code></pre><h3 id="ARC的引子">ARC的引子</h3><p>（这里，为ARC开个头，具体内容请看下回分析。）</p>
<p>顾名思义，ARC就是交给编译器来管理引用计数，而大家都知道Objc是通过引用计数来管理内存的，也就是说现在的内存管理已经不需要程序员来操心了（大多数情况下）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近和同事在讨论一个循环引用问题的时候，不经意间讨论到了内存管理的本质到底是什么，于是翻出《Objective-C高级编程》一看，但是发现上面有些问题，可能是比较旧了，苹果有了新的实现，所以拿出Objc源码研究了下，下面是自己研究的内容，如果理解有误，请定要联系我纠正。</p>
<h3 id="内存管理">内存管理</h3><p>大家都知道，Objc是通过引用计数来管理内存的（Mac除外啊，毕竟处理器牛逼），主要就遵循以下几个原则：</p>
<ol>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要持有的对象，自己可以释放。</li>
<li>非自己持有的对象不能释放。</li>
</ol>
<p>其实这些就是对应了Objc中得alloc，retain等方法，这些是引用计数的思考方式，并不因是否ARC改变，那么接下来看一下一些底层实现。</p>]]>
    
    </summary>
    
      <category term="ARC" scheme="http://blog.tracyone.com/tags/ARC/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Think in Block(下)]]></title>
    <link href="http://blog.tracyone.com/2015/06/10/Think-in-Block-%E4%B8%8B/"/>
    <id>http://blog.tracyone.com/2015/06/10/Think-in-Block-下/</id>
    <published>2015-06-10T13:28:22.000Z</published>
    <updated>2015-06-20T02:57:24.000Z</updated>
    <content type="html"><![CDATA[<p>这一篇主要浅析下Block和Objc的关系，更加偏向于实际应用。其实大多数时间我们是和Objc对象打交道，知道一点原理，能避免死的不明不白。</p>
<p>在这个过程中也会回答前面留下的坑- -，探究下来感觉，纸上得来终觉浅，以前也看过这本书，但是一直没有动手敲代码，浮于表面了。</p>
<h3 id="截获Objc对象">截获Objc对象</h3><p>先看下源程序，声明了一个Block对象，这次用到了copy，然后最后调用了三次，输出的结果是1，2，3。这一次转换后的代码非常多，不过抽离出来后也很简洁。</p>
<a id="more"></a>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)(<span class="keyword">id</span> obj);
<span class="keyword">int</span> main(){

    blk_t blk;
    {
        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];

        blk = [^(<span class="keyword">id</span> obj){
            [array addObject:obj];

            <span class="built_in">NSLog</span>(<span class="string">@"array count = %ld"</span>, [array count]);
        } <span class="keyword">copy</span>];
    }

    blk([[<span class="built_in">NSObject</span> alloc] init]);
    blk([[<span class="built_in">NSObject</span> alloc] init]);
    blk([[<span class="built_in">NSObject</span> alloc] init]);
}
</code></pre><p>在这里，我们能够看出来，Block对于Objc对象的截获是通过指针，并且和外部修饰符一致，也就是说外部是strong，内部也是strong，然后c结构体中并不能很好地管理内存，所以其实是通过运行时来掌控的，也就是后面会看到的copy和dispose函数的作用。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(*blk_t)(<span class="keyword">id</span> obj);
<span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  <span class="keyword">id</span> array;
  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">id</span> _array, <span class="keyword">int</span> flags=<span class="number">0</span>) : array(_array) {
    impl<span class="variable">.isa</span> = &amp;_<span class="built_in">NSConcreteStackBlock</span>;
    impl<span class="variable">.Flags</span> = flags;
    impl<span class="variable">.FuncPtr</span> = fp;
    Desc = desc;
  }
};

<span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself, <span class="keyword">id</span> obj) {
      <span class="keyword">id</span> array = __cself-&gt;array; <span class="comment">// bound by copy</span>

      ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)array, sel_registerName(<span class="string">"addObject:"</span>), (<span class="keyword">id</span>)obj);

      <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__<span class="built_in">NSConstantStringImpl__var_folders_hv_3dth3by12sg3t1g37hq5plkw0000gn_T_main_18c6fa_mi_0</span>, ((<span class="built_in">NSUInteger</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)array, sel_registerName(<span class="string">"count"</span>)));
}
</code></pre><ol>
<li>在把Block对象拷贝到堆上的时候copy函数会被调用，而在Block从堆上释放的时候dispose会被调用。</li>
<li>在调用copy函数的时候_Block_object_assign将外部对象赋值给Block结构体的成员变量，并持有它。</li>
<li>在调用dispose函数的时候_Block_object_dispose将释放Block结构体的成员变量。</li>
</ol>
<p>有了这些隐藏在背后的操作后，通过使用strong类型的局部对象，Block截获后能够在超出其变量作用域而存在。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) {
    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="built_in">array</span>, (<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);
}

<span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) {
    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);
}

<span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 {
  <span class="keyword">size_t</span> reserved;
  <span class="keyword">size_t</span> Block_size;
  <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);
  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);
} __main_block_desc_0_DATA = { <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
</code></pre><p>其实回过头去看一下截获__block变量的时候也生成了两个类似的函数，唯一的区别是BLOCK_FIELD_IS_OBJECT和BLOCK_FIELD_IS_BYREF，这只是用来标示这是一个对象，还是一个变量。</p>
<pre><code>int main<span class="params">()</span>{

    blk_t blk;
    {
        id array = <span class="params">(<span class="params">(NSMutableArray *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(NSMutableArray *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSMutableArray"</span>)</span>, sel_registerName<span class="params">(<span class="string">"alloc"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"init"</span>)</span>)</span>;

        blk = <span class="params">(blk_t)</span><span class="params">(<span class="params">(id <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>&amp;__main_block_impl_0<span class="params">(<span class="params">(void *)</span>__main_block_func_0, &amp;__main_block_desc_0_DATA, array, <span class="number">570425344</span>)</span>, sel_registerName<span class="params">(<span class="string">"copy"</span>)</span>)</span>;
    }


    <span class="params">(<span class="params">(void <span class="params">(*)</span><span class="params">(__block_impl *, id)</span>)</span><span class="params">(<span class="params">(__block_impl *)</span>blk)</span>-&gt;FuncPtr)</span><span class="params">(<span class="params">(__block_impl *)</span>blk, <span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"alloc"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"init"</span>)</span>)</span>)</span>;
    <span class="params">(<span class="params">(void <span class="params">(*)</span><span class="params">(__block_impl *, id)</span>)</span><span class="params">(<span class="params">(__block_impl *)</span>blk)</span>-&gt;FuncPtr)</span><span class="params">(<span class="params">(__block_impl *)</span>blk, <span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"alloc"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"init"</span>)</span>)</span>)</span>;
    <span class="params">(<span class="params">(void <span class="params">(*)</span><span class="params">(__block_impl *, id)</span>)</span><span class="params">(<span class="params">(__block_impl *)</span>blk)</span>-&gt;FuncPtr)</span><span class="params">(<span class="params">(__block_impl *)</span>blk, <span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"alloc"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"init"</span>)</span>)</span>)</span>;

}
</code></pre><p>tips：上面这些代码其实和书上的有一定的区别，也即是前面说得，我们的技术在提升，当然苹果没有理由不提升，不管是编译器还是底层实现。其实这里加不加copy都一样，因为赋值给strong类型的变量会自动copy。</p>
<h3 id="循环引用">循环引用</h3><p>由于上边所示那样的内存管理机制，当我们截获strong类型的对象时，很容易出现循环引用，但是也不用担心，没必要无时不刻的用一个__weak来避免，盲目地使用只会暴露出并没有深入地理解。</p>
<p>这里给出三种方法来避免循环引用：</p>
<ol>
<li>__weak 修饰符</li>
</ol>
<p>通过weak肯定能解除循环引用，但也有缺点，有时候我们会在内部使用strong来保证执行block的时候外部变量不会释放，但这也不能避免在block执行前已经释放了的这种情形。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)();
<span class="class"><span class="keyword">@interface</span> <span class="title">Block</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)blk_t blk;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">Block</span></span>
- (instancetype)init{
    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {
        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;
        <span class="keyword">self</span><span class="variable">.blk</span> = ^{
            <span class="built_in">NSLog</span>(<span class="string">@"test%@"</span>, weakSelf<span class="variable">.array</span>);
        };
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
<span class="keyword">@end</span>
</code></pre><ol>
<li>__block修饰符+nil操作</li>
</ol>
<p>这种情况则也能避免循环引用，但是有个前提，这个Block必须在某个地方执行，否则还是不能打破循环引用环，但是这么做的好处还是很多的，首先可以延长生命周期，其次在执行Block的时候可以决定是否是将nil赋予，还是给另一个值。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)();
<span class="class"><span class="keyword">@interface</span> <span class="title">Block</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)blk_t blk;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">Block</span></span>
- (instancetype)init{
    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {

        __block <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;

        <span class="keyword">self</span><span class="variable">.blk</span> = ^{
            <span class="built_in">NSLog</span>(<span class="string">@"test%@"</span>, weakSelf<span class="variable">.array</span>);
            weakSelf = <span class="literal">nil</span>;
        };
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
<span class="keyword">@end</span>
</code></pre><ol>
<li><strong>unsafe</strong>unretain修饰符</li>
</ol>
<p>这其实只是用在一些weak不支持的场合，现在几乎不怎么用了。</p>
<p>三者各有优缺点，<strong>weak不能够延长生命周期，</strong>block修饰符，如果最后没有执行，导致赋值nil不能够执行则还是会循环引用，<strong>unsafe</strong>unretain和weak相似，但是有可能会出现野指针的情况。</p>
<h3 id="MRC下地Block">MRC下地Block</h3><ul>
<li>在mrc下需要手动的调用copy和release，只要是copy到堆上了，则可以使用retain来持有，否则retain并没有效果。</li>
<li>在C语言中也支持，使用的是Block_copy和Block_release函数。</li>
<li>在ARC无效的时候我们只需要使用<strong>block就能避免循环引用了，这是因为，在mrc下</strong>block对象不会被retain。</li>
</ul>
<h3 id="结束语">结束语</h3><p>关于Block的探究也差不多了，接下来就是实战中去体会了，不过在探究的过程中发现，是时候去深入地理解一下Objc的内存管理机制，同时也发现在这本书中的ARC讲解已经有点过时了，有些和真实地情况有出入。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一篇主要浅析下Block和Objc的关系，更加偏向于实际应用。其实大多数时间我们是和Objc对象打交道，知道一点原理，能避免死的不明不白。</p>
<p>在这个过程中也会回答前面留下的坑- -，探究下来感觉，纸上得来终觉浅，以前也看过这本书，但是一直没有动手敲代码，浮于表面了。</p>
<h3 id="截获Objc对象">截获Objc对象</h3><p>先看下源程序，声明了一个Block对象，这次用到了copy，然后最后调用了三次，输出的结果是1，2，3。这一次转换后的代码非常多，不过抽离出来后也很简洁。</p>]]>
    
    </summary>
    
      <category term="block" scheme="http://blog.tracyone.com/tags/block/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Think in Block(上)]]></title>
    <link href="http://blog.tracyone.com/2015/06/07/Think-in-Block-%E4%B8%8A/"/>
    <id>http://blog.tracyone.com/2015/06/07/Think-in-Block-上/</id>
    <published>2015-06-07T13:14:38.000Z</published>
    <updated>2015-06-20T02:57:26.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Block_简介">Block 简介</h2><p>这不是一篇介绍如何使用Block的文章，主要想要探究一下系统背后Block发生了什么，主要参考的是《Objective-C高级编程》这本书，不过这本书本身也有些年代了，苹果实现的机制也有了一些改变。实践出真知，不清楚的地方自己动手试一下，会有意外地收获。</p>
<h3 id="Block是什么">Block是什么</h3><p>苹果官网说法：<br>A block is an anonymous inline collection of code, and sometimes also called a “closure”.</p>
<p>通俗的讲：<br>闭包就是能够读取其它函数内部变量的匿名函数</p>
<p>与普通函数的区别：<br>普通函数能使用局部变量，参数，静态变量，静态全局，全局变量，并且有自己的函数名。<br>block除了能使用这些外还能使用其他函数内的变量，而且没有函数名。</p>
<a id="more"></a>
<h3 id="BLock的用法和功能">BLock的用法和功能</h3><h5 id="语法">语法</h5><p>void (^)(void){<br>};<br>与C语言函数相比没有函数名，带有^；可省略很多部分。</p>
<h5 id="变量">变量</h5><p>void (^var)(void)；<br>与C语言函数指针相比只是把*改成了^,Block变量和普通变量作用完全相同。</p>
<ol>
<li>通过typedef可以简化声明</li>
<li>调用和C语言函数调用一样，变量名+小括号</li>
</ol>
<h5 id="截获变量">截获变量</h5><ol>
<li>Block可以使用在它之前声明的局部变量，因此在执行Block时，即使已经改变了值，也不影响Block中截获的值。</li>
<li>一般情况，Block只能保存声明时的瞬间值，保存后就不能修改了；如果需要改变则要附加__block.</li>
<li>如果截获的是oc对象，使用是没有问题的，但是如果要重新赋值，则也必须加__block。</li>
</ol>
<h3 id="Block的实现">Block的实现</h3><h5 id="Block的本质">Block的本质</h5><p>先看下源代码：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{

    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
        <span class="built_in">printf</span>(<span class="string">"Block\n"</span>);
    };

    blk();
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>很简单，简单地定义一个Block，赋给blk对象，然后调用这个Block，那么这段代码经过编译器编译过后，发生了什么呢？我们用Clang 命令 -rewirte-objc转换成c++看下编译器搞得什么鬼！</p>
<p>首先是这一段，这段代码是编译器插入的代码，主要作用就是声明了一个结构体，这可以看成是我们的<code>Block类</code>的数据部分</p>
<pre><code><span class="preprocessor">#ifndef BLOCK_IMPL</span>
<span class="preprocessor">#define BLOCK_IMPL</span>
<span class="keyword">struct</span> __block_impl {
  <span class="keyword">void</span> *isa;
  <span class="keyword">int</span> Flags;
  <span class="keyword">int</span> Reserved;
  <span class="keyword">void</span> *FuncPtr;
};
</code></pre><p>这一段则是系统给我们声明的真正的<code>Block类</code>，其中包括了数据部分和一些描述性内容，以及一个初始化函数。</p>
<pre><code><span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl <span class="keyword">impl</span>;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) {
    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;
    <span class="keyword">impl</span>.Flags = flags;
    <span class="keyword">impl</span>.FuncPtr = fp;
    Desc = desc;
  }
};
</code></pre><p>这一段则是赋值给Block变量中的那个函数的声明，其中会把self传入，这个很多语言都会这么处理，在内部使用self的时候能够找到真实地那个对象。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) {

        <span class="built_in">printf</span>(<span class="string">"Block\n"</span>);
    }
</code></pre><p>这一段则是前面所说的描述性的内容，主要就是Block对象的大小，因为这个例子比较简单，复杂的情况这里还会生成其他的一些函数，后面会讲到。<br>    static struct <strong>main_block_desc_0 {<br>      size_t reserved;<br>      size_t Block_size;<br>    } </strong>main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};</p>
<p>最后则是这一段我们写得main函数的代码，通过调用__main_block_impl_0函数来初始化一个Block对象，最后调用也就是简单地用c语言函数指针的方式调用。<br>    int main() {</p>
<pre><code>    void <span class="comment">(*blk)(void) = (void (*)</span>())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);

    ((void <span class="comment">(*)(__block_impl *)</span>)((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
    return <span class="number">0</span>;
}
</code></pre><p>从isa的存在我们也大概能够看出来Block其实就是Objc的对象，只不过这是一个为了性能考虑而可能在栈上生成的一个对象。</p>
<h5 id="如何截获自动变量">如何截获自动变量</h5><p>这一次尝试一下使用Block来截获外部变量，看一下，Block如何能够使用外部变量，原函数：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span>{

    <span class="keyword">int</span> dmy = <span class="number">256</span>;
    <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">10</span>;
    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"var = %d\n"</span>;

    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
        printf(fmt, <span class="keyword">var</span>);
    };

    <span class="keyword">var</span> = <span class="number">2</span>;
    fmt = <span class="string">"Real var = %d\n"</span>;

    blk();
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>重写以后发现，其实没有多大改变，只是多了一些内容：</p>
<ul>
<li>__main_block_impl_0中多了一个指针fmt，和int类型的变量，其实也很容易理解，就是用来存放外部变量的。</li>
<li>__main_block_impl_0初始化的时候会同时对成员变量赋值。</li>
<li>__main_block_func_0中会在开始的地方帮你声明两个同名的变量，赋值的值则是从传入的self通过指针取值。</li>
</ul>
<p>那么其实从这些我们也不难看出，Block其实只截获了内部用到对象，以及为什么Block中普通截获的值不能改变，当然不能改写只是编译器检查，因为改了也没用。</p>
<pre><code><span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;
  <span class="keyword">int</span> <span class="keyword">var</span>;
  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _var, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), <span class="keyword">var</span>(_var) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
<span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) {
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// bound by copy</span>
  <span class="keyword">int</span> <span class="keyword">var</span> = __cself-&gt;<span class="keyword">var</span>; <span class="comment">// bound by copy</span>

        printf(fmt, <span class="keyword">var</span>);
    }

<span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)};
<span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span>{

    <span class="keyword">int</span> dmy = <span class="number">256</span>;
    <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">10</span>;
    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"var = %d\n"</span>;

    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, <span class="keyword">var</span>);

    <span class="keyword">var</span> = <span class="number">2</span>;
    fmt = <span class="string">"Real var = %d\n"</span>;

    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><h3 id="__block的作用">__block的作用</h3><p>首先来看下，有哪些变量是就算不在函数内声明，函数中也能使用和改变值的：静态变量，静态全局，全局变量。那这些变量是通过什么方式来实现的呢？<br>对于全部变量来说，其实本身它的作用域就已经包括了函数所在区域，能使用并不奇怪，普通的静态变量其实是通过指针来做到的。<br>那其实也不难推出，__block基本上来说也是通过指针（因为这也是最简单地一种方法）。<br>废话不多说，上代码：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span>{

    __block <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">10</span>;
    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
        <span class="keyword">var</span> = <span class="number">1</span>;
    };
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>经过重写后发现，增加了狂多代码，不过不用慌，都是可读性很强的代码，慢慢分析。</p>
<p>这一段就是<strong>block说明符修饰过后的变量最终声明的结构体，其中 </strong>forwarding很重要（这个是不同存储区域能访问到同一个变量的关键）</p>
<pre><code><span class="keyword">struct</span> __Block_byref_var_0 {
  <span class="keyword">void</span> *__isa;
__Block_byref_var_0 *__forwarding;
 <span class="keyword">int</span> __flags;
 <span class="keyword">int</span> __size;
 <span class="keyword">int</span> <span class="keyword">var</span>;
};
</code></pre><p>在这里大概也看出了一点端倪，其实传给var指针的是_var-&gt;<strong>forwarding，后面会给出 </strong>forwarding指向的是谁。</p>
<pre><code>struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* <span class="type">Desc</span>;
  __Block_byref_var_0 *<span class="keyword">var</span>; // by <span class="keyword">ref</span>
  __main_block_impl_0(<span class="type">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_var_0 *_var, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="keyword">var</span>(_var-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.<span class="type">Flags</span> = flags;
    impl.<span class="type">FuncPtr</span> = fp;
    <span class="type">Desc</span> = desc;
  }
};
</code></pre><p>看到这，基本就知道为什么用__block修饰的变量，在Block中也能改变了，因为内部声明时是用了指针嘛。</p>
<pre><code><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_var_0 *<span class="keyword">var</span> = __cself-&gt;<span class="keyword">var</span>; // bound by <span class="keyword">ref</span>

        (<span class="keyword">var</span>-&gt;__forwarding-&gt;<span class="keyword">var</span>) = <span class="number">1</span>;
    }
</code></pre><p>这里的copy，和dispose先略过，在后续的Objc对象那部分会详解。<br>    static void <strong>main_block_copy_0(struct </strong>main_block_impl_0<em>dst, struct __main_block_impl_0</em>src) {_Block_object_assign((void<em>)&amp;dst-&gt;var, (void</em>)src-&gt;var, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);}</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) {_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;var, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);}

<span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 {
  <span class="keyword">size_t</span> reserved;
  <span class="keyword">size_t</span> Block_size;
  <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);
  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);
} __main_block_desc_0_DATA = { <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
</code></pre><p>通过这一段，可以看出其实var已经不是简单地Int类型了，变得老长老长了，编译器总是在默默中给我们加了点料。同时也知道了__forwarding指向的是var自身。<br>    int main() {</p>
<pre><code>    __attribute__<span class="params">(<span class="params">(__blocks__<span class="params">(byref)</span>)</span>)</span> __Block_byref_var_0 var = {<span class="params">(void*)</span><span class="number">0</span>,<span class="params">(__Block_byref_var_0 *)</span>&amp;var, <span class="number">0</span>, sizeof<span class="params">(__Block_byref_var_0)</span>, <span class="number">10</span>};
    void <span class="params">(*blk)</span><span class="params">(void)</span> = <span class="params">(void <span class="params">(*)</span><span class="params">()</span>)</span>&amp;__main_block_impl_0<span class="params">(<span class="params">(void *)</span>__main_block_func_0, &amp;__main_block_desc_0_DATA, <span class="params">(__Block_byref_var_0 *)</span>&amp;var, <span class="number">570425344</span>)</span>;
    return <span class="number">0</span>;
}
</code></pre><h3 id="Block,__block存储域">Block,__block存储域</h3><p>Q:Block超出变量作用域可存在？</p>
<p>A:</p>
<ol>
<li>配置在全局变量中的Block，在变量作用域之外也可以通过指针安全的使用</li>
<li>在栈上的Block则是通过复制到堆上来解决的</li>
<li>而<strong>block变量用 </strong>forward可以实现无论配置在哪都可以正确地访问 __block变量</li>
<li>在ARC下，大多数情况下编译器会恰当的判断，自动将Block从栈上复制到堆上。（autorelease）</li>
</ol>
<p>补充：</p>
<ul>
<li>自动copy：Block作为函数的返回值时</li>
<li>手动copy：向方法或函数的参数中传递Block（但是可以在函数中适当地copy就不必在传递前copy）（例如GCD，Animation等）</li>
</ul>
<p>Q:调用Copy时不同的Block对象究竟发生了什么：</p>
<ol>
<li>_NSConcreteStackBlock            ：从栈复制到堆</li>
<li>_NSConcreteGlobalBlock            ：什么也不做</li>
<li>_NSConcreteMallocBlock            ：引用计数增加</li>
</ol>
<p>Q:调用Copy时不同的__block对象究竟发生了什么：</p>
<ol>
<li>栈            ：从栈复制到堆，并且被Block持有</li>
<li>堆            ：被Block持有</li>
</ol>
<h3 id="新的开始">新的开始</h3><p>这一篇，主要把Block变量和__block变量分析了一下，对于Objc中得对象，Block如何处理放到下一篇详细的讲述，同时下一篇也会详细的讲解一下避免Block循环引用的N种姿势。以及之前没有讲得copy和dispose是干嘛的，顺带着还会说一下mrc下地Block。</p>
<p>当然本人才疏学浅，上面只是个人的一些理解，可能会有偏差，如果有误，欢迎吐槽纠正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Block_简介">Block 简介</h2><p>这不是一篇介绍如何使用Block的文章，主要想要探究一下系统背后Block发生了什么，主要参考的是《Objective-C高级编程》这本书，不过这本书本身也有些年代了，苹果实现的机制也有了一些改变。实践出真知，不清楚的地方自己动手试一下，会有意外地收获。</p>
<h3 id="Block是什么">Block是什么</h3><p>苹果官网说法：<br>A block is an anonymous inline collection of code, and sometimes also called a “closure”.</p>
<p>通俗的讲：<br>闭包就是能够读取其它函数内部变量的匿名函数</p>
<p>与普通函数的区别：<br>普通函数能使用局部变量，参数，静态变量，静态全局，全局变量，并且有自己的函数名。<br>block除了能使用这些外还能使用其他函数内的变量，而且没有函数名。</p>]]>
    
    </summary>
    
      <category term="block" scheme="http://blog.tracyone.com/tags/block/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
</feed>