<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[TracyOne]]></title>
  <subtitle><![CDATA[iOS Rookie]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.tracyone.com//"/>
  <updated>2015-06-18T15:23:28.000Z</updated>
  <id>http://blog.tracyone.com//</id>
  
  <author>
    <name><![CDATA[Tracy Wang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[iOS菜鸟的CS之路（计算机系统漫游）]]></title>
    <link href="http://blog.tracyone.com/2015/06/18/iOS%E8%8F%9C%E9%B8%9F%E7%9A%84CS%E4%B9%8B%E8%B7%AF%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8%EF%BC%89/"/>
    <id>http://blog.tracyone.com/2015/06/18/iOS菜鸟的CS之路（计算机系统漫游）/</id>
    <published>2015-06-18T15:08:16.000Z</published>
    <updated>2015-06-18T15:23:28.000Z</updated>
    <content type="html"><![CDATA[<p>计算机系统是由硬件+软件构成，共同工作来运行应用程序。由一个非常简单的例子入手观察在整个程序生命周期中，计算机系统分别承担了什么样的责任。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio,h&gt;</span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="built_in">printf</span>(<span class="string">"hello, world"</span>);
}
</code></pre><h2 id="系统简介">系统简介</h2><ol>
<li>信息就是位+上下文</li>
</ol>
<p>这是一个很简单的C语言源程序，在计算机系统中，像这样的源程序一般都是由ASCⅡ字符构成，也称为文本文件，其他文件则称为二进制文件。这也透露出来一个基本的理念：系统中所有的信息（磁盘上的，存储器中得，网络中得）都是由一串位表示的，唯一区别只是上下文。</p>
<a id="more"></a>
<ol>
<li>程序被其他程序翻译成不同的格式</li>
</ol>
<p>本身hello程序没有任何意义，只是一个简单地C语言源程序，能够被人读懂，但是系统却不认识。但是经过编译系统一系列的处理过后，最终会称为一个可执行的目标程序。具体的翻译过程是这样的：</p>
<p>hello.c  - (预处理器) - hello.i    - (编译器) - hello.s - (汇编器) - hello.o - (链接器) - hello</p>
<ul>
<li>第预处理阶段，经过预处理器展开预处理程序，填充stdio库中得程序得到另一个C程序，通常用.i做后缀。</li>
<li>编译阶段，经过编译器翻译成汇编程序，这时候语言已经很接近机器指令了，<code>不同的的高级语言，不同的编译器，最终得到的却是通用的汇编程序</code></li>
<li>汇编阶段，通过汇编器将汇编程序翻译成机器语言指令，然后打包成一种叫<code>relocatable object program</code>格式的目标文件</li>
<li>链接阶段，链接器把不同的目标程序链接合并处理，最终产出一个可执行文件。</li>
</ul>
<ol>
<li><p>了解编译系统如何工作的益处</p>
<ul>
<li><p>优化程序性能 （一个switch语句是否总是比一系列if-else高校，一个函数调用的开销有多大，while和for哪个更有效，指针还是数组等等）</p>
</li>
<li><p>理解链接时出现的错误 （很长时间，在链接过程的错误总是最让人头疼的，静态库和动态库的区别，有些问题会知道运行时才暴露等等）</p>
</li>
<li><p>避免安全漏洞 （缓冲区溢出是困扰网络和Internet服务器上安全漏洞的主要原因）</p>
</li>
</ul>
</li>
</ol>
<h2 id="处理器">处理器</h2><ol>
<li>处理器读并解释存储在存储器中得指令</li>
</ol>
<p>当前面的程序已经翻译成一个可执行程序后，我们开始在操作系统上执行，会在控制台上打印出hello， world这些内容，那么这之间发生了什么呢？</p>
<h3 id="硬件组成">硬件组成</h3><ul>
<li><p>总线 （通常总线被设计成传送定长的字节块，其中字节长是一个基本系统参数，比如常用的32位，64位分别对应了4字节长，和8字节长。）</p>
</li>
<li><p>I/O设备 （这是一个很广的概念，鼠标，键盘，显示器属于I/O设备，硬盘等也是。一种是本身就在主板上得，一种是适配器插上去的。）</p>
</li>
<li><p>主存 （也称为内存，是由一组DRAM芯片组成，是一个线性的字节数组，每个字节都有一个唯一的地址，从零开始。一般来说不同的机器每一天机器指令的长度不相同。）</p>
</li>
<li><p>处理器 （CPU，简称处理器，用来执行存储在主存中指令的引擎，由寄存器，程序计数器（PC），算数/逻辑单元（ALU）组成。）</p>
</li>
</ul>
<h3 id="软件运行">软件运行</h3><p>在整个运行期间，先把存放在磁盘上得可执行文件传送到主存（通过直接存储器（DMA）），然后再到寄存器。</p>
<ol>
<li>高速缓存的重要性</li>
</ol>
<p>前面整个过程可以看出，有大量的时间是用在资源的传输上，于是聪明的系统设计者就在处理器和主存间加入了<code>高速缓存存储器</code>，访问速度几乎和寄存器一样快。L1和L2运用的是一种静态随机访问存储器（SRAM）的硬件技术实现，现在很多还加入了L3缓存。</p>
<ol>
<li>存储设备的层级结构</li>
</ol>
<p>寄存器 -&gt; L1高速缓存（SRAM） -&gt; L2高速缓存（SRAM） -&gt; L3高速缓存（SRAM） -&gt; 主存（DRAM）-&gt; 本地二级存储（磁盘） -&gt; 远程二级存储（分布式，Web）。</p>
<h2 id="操作系统">操作系统</h2><p>在hello程序中我们并没有直接调用键盘，显示器等，这些其实都是由操作系统完成的，在应用程序和硬件之间。操作系统有两个基本功能：</p>
<ul>
<li>防止硬件被滥用。</li>
<li>向应用提供简单一致的控制硬件机制。</li>
</ul>
<p>总的来说，文件是对I/O设备的抽象，虚拟存储器是对主存和磁盘I/O的抽象，进程则是对处理器，主存和磁盘I/O的抽象。</p>
<ol>
<li>进程和线程</li>
</ol>
<p>进程是操作系统对一个正在运行程序的抽象，无论是在单核，还是多核系统中，一个CPU看上去都像在并发的执行多个进程，这是通过处理器在进程间切换实现的，这种交错机制也称为上下文切换。</p>
<p>通常情况下一个进程只有单一的控制流，但是现代系统中，一个线程实际上可以由多个线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样地代码和全局数据。</p>
<ol>
<li>虚拟存储器</li>
</ol>
<p>这是一个抽象的概念，为进程提供一个假象，好似每个进程都在独占整个主存。每个进程看到的都是一直的存储器，称为虚拟地址空间。</p>
<ul>
<li>程序代码和数据 （对于所有的进程来说，代码是从一个固定的地址开始的，紧接着是C全局变量相对应的数据位置。</li>
<li>堆     （运行时使用的堆，代码和数据区在刚开始运行已经被设定好大小，而堆是动态分配的）</li>
<li>共享库 （大致是放一些C标准库，数学库这样的共享库的代码和数据区）</li>
<li>栈     （位于虚拟地址空间顶部，编译器用来实现函数调用，可以动态扩展和收缩）</li>
<li>内核虚拟存储器 （内核总是驻留在内存中，顶部空间是为内核预留的）</li>
</ul>
<ol>
<li>文件</li>
</ol>
<p>文件就是字节序列，每个I/O设备都看看成文件，向应用程序提供了一个统一的视角。</p>
<h2 id="重要主题">重要主题</h2><ol>
<li>网络通信</li>
</ol>
<p>前面我们都是孤立的看待系统，分为硬件和软件，实际上在现代系统中已经离不开网络的存在。从一个单独的系统来看，网络可以视为一个I/O设备，通过一个网络适配器，系统可以读取其他机器发来的数据。</p>
<ol>
<li><p>并发和并行</p>
<ul>
<li><p>线程级并发 （可以使应用程序更快，可以并行地高效执行）</p>
</li>
<li><p>指令级并行 （处理器可以同时执行多条指令的属性称为指令级并行）</p>
</li>
<li><p>单指令，多数据并行 （允许一条指令产生多个可以并行执行的操作）</p>
</li>
</ul>
</li>
<li><p>计算机系统中抽象的重要性</p>
</li>
</ol>
<p>无需了解内部实现可以使用，前面介绍了三种抽象，再往外扩展，虚拟机则是对整个计算机（操作系统，处理器，程序）的抽象。</p>
<h2 id="总结">总结</h2><ol>
<li><p>计算机系统是由硬件和软件组成，共同协作运行程序，内部信息通过位表示，根据不同的上下文解释不同，经过编译系统翻译成可执行文件。</p>
</li>
<li><p>处理器读取并解释在主存中得二进制指令，由于大量时间花费在数据传输中，所以引入缓存机制，存储结构分级。</p>
</li>
<li><p>操作系统内核是应用程序和硬件的媒介，提供了三种抽象：文件，虚拟存储器和进程。</p>
</li>
<li><p>最后网络提供了计算机之间通信的手段，换个角度看，网络也是一种I/O。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>计算机系统是由硬件+软件构成，共同工作来运行应用程序。由一个非常简单的例子入手观察在整个程序生命周期中，计算机系统分别承担了什么样的责任。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio,h&gt;</span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="built_in">printf</span>(<span class="string">"hello, world"</span>);
}
</code></pre><h2 id="系统简介">系统简介</h2><ol>
<li>信息就是位+上下文</li>
</ol>
<p>这是一个很简单的C语言源程序，在计算机系统中，像这样的源程序一般都是由ASCⅡ字符构成，也称为文本文件，其他文件则称为二进制文件。这也透露出来一个基本的理念：系统中所有的信息（磁盘上的，存储器中得，网络中得）都是由一串位表示的，唯一区别只是上下文。</p>]]>
    
    </summary>
    
      <category term="CS" scheme="http://blog.tracyone.com/tags/CS/"/>
    
      <category term="Computer System" scheme="http://blog.tracyone.com/categories/Computer-System/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出ARC(下)]]></title>
    <link href="http://blog.tracyone.com/2015/06/16/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAARC-%E4%B8%8B/"/>
    <id>http://blog.tracyone.com/2015/06/16/深入浅出ARC-下/</id>
    <published>2015-06-16T14:24:52.000Z</published>
    <updated>2015-06-16T14:27:08.000Z</updated>
    <content type="html"><![CDATA[<p>终于到最后一篇了，前面两篇几乎没有涉及到ARC，全是内存管理，这一次要好好研究一下ARC的底层实现，在看的过程中感觉以前学得C++忘的差不多了。这一篇主要讲ARC的<strong>strong,</strong>weak,__autorelease修饰符背后发生了什么。</p>
<h3 id="__strong">__strong</h3><p>找了很多资料，发现还是书上的解释比较靠谱，在strong类型对象超出作用域后会调用objc_release函数，当然在属性为strong的情况下赋值是会走这个方法objc_storeStrong，这个也是比较标准的setter方法的写法。<br><a id="more"></a><br>1.先取得原先的对象，然后和新的对象比较，如果是同一个则直接返回，然后对新的对象retain，赋给老得对象，然后再release老的对象，来保证赋值给strong类型的属性时可以正常的retainCount+1.</p>
<pre><code>void
objc_storeStrong<span class="list">(<span class="keyword">id</span> <span class="variable">*location, id obj)
{
    id prev = *</span>location<span class="comment">;</span>
    if <span class="list">(<span class="keyword">obj</span> == prev)</span> {
        return<span class="comment">;</span>
    }
    objc_retain<span class="list">(<span class="keyword">obj</span>)</span><span class="comment">;</span>
    <span class="variable">*location = obj;
    objc_release(prev);
}</span></span>
</code></pre><h3 id="__strong中的autorelease">__strong中的autorelease</h3><p>对于一个非持有对象赋值给strong类型的变量时，编译器会插入两个比较有意思的函数,这两个函数可以极大减少开销，减轻autoreleasePool的负担。</p>
<p>1.两个函数都会做一个校验，看是否能够不加入autoreleasePool，直接返回对象。</p>
<pre><code><span class="property">id</span> 
objc_autoreleaseReturnValue(<span class="property">id</span> obj)
{
    <span class="keyword">if</span> (fastAutoreleaseForReturn(obj)) <span class="constant">return</span> obj;
<span class="command">
    return</span> objc_autorelease(obj);
}

<span class="property">id</span>
objc_retainAutoreleasedReturnValue(<span class="property">id</span> obj)
{
    <span class="keyword">if</span> (fastRetainFromReturn(obj)) <span class="constant">return</span> obj;
<span class="command">
    return</span> objc_retain(obj);
}
</code></pre><p>2.这两个函数则是揭秘了如何做到不加入autereleasePool而延长生命周期的，具体并没有看太懂，貌似是和线程有关，通过线程的内存中转一下。看了一下，不同的cpu架构实现方式都不同。</p>
<pre><code><span class="keyword">static</span> ALWAYS_INLINE 
<span class="keyword">bool</span> fastAutoreleaseForReturn(<span class="keyword">id</span> obj)
{
    assert(tls_get_direct(AUTORELEASE_POOL_RECLAIM_KEY) == <span class="literal">nil</span>);

    <span class="keyword">if</span> (callerAcceptsFastAutorelease(__builtin_return_address(<span class="number">0</span>))) {
        tls_set_direct(AUTORELEASE_POOL_RECLAIM_KEY, obj);
        <span class="keyword">return</span> <span class="literal">true</span>;
    }

    <span class="keyword">return</span> <span class="literal">false</span>;
}


<span class="keyword">static</span> ALWAYS_INLINE
<span class="keyword">bool</span> fastRetainFromReturn(<span class="keyword">id</span> obj)
{
    <span class="keyword">if</span> (obj == tls_get_direct(AUTORELEASE_POOL_RECLAIM_KEY)) {
        tls_set_direct(AUTORELEASE_POOL_RECLAIM_KEY, <span class="number">0</span>);
        <span class="keyword">return</span> <span class="literal">true</span>;
    }

    <span class="keyword">return</span> <span class="literal">false</span>;
}
</code></pre><h3 id="__weak">__weak</h3><p>赋值给weak类型变量的对象主要会经过这几步</p>
<p>1.编译器增加objc_initWeak函数调用，然后会调用objc_storeWeak函数。</p>
<pre><code>id
objc_initWeak(id *addr, id <span class="function"><span class="keyword">val</span>)
</span>{
    *addr = <span class="number">0</span>;
    <span class="keyword">if</span> (!<span class="function"><span class="keyword">val</span>) <span class="title">return</span> <span class="title">nil</span>;</span>
    <span class="keyword">return</span> objc_storeWeak(addr, <span class="function"><span class="keyword">val</span>);</span>
}
</code></pre><p>2.这个函数看上去做了很多事，其实很多都可以略过不看，主要做了通过weak_unregister_no_lock函数把原来的对象unregister，通过weak_register_no_lock函数把新的对象register进去。最后一步就是通过setWeaklyReferenced_nolock函数使得引用计数那张散列表的weak引用对象的引用计数中标示为weak引用。</p>
<pre><code><span class="function">id
<span class="title">objc_storeWeak</span><span class="params">(id *location, id newObj)</span>
</span>{
    id oldObj;
    SideTable *oldTable;
    SideTable *newTable;
    <span class="keyword">spinlock_t</span> *lock1;
<span class="preprocessor">#<span class="keyword">if</span> SIDE_TABLE_STRIPE &gt; 1</span>
    <span class="keyword">spinlock_t</span> *lock2;
<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="comment">// Acquire locks for old and new values.</span>
    <span class="comment">// Order by lock address to prevent lock ordering problems. </span>
    <span class="comment">// Retry if the old value changes underneath us.</span>
 retry:
    oldObj = *location;

    oldTable = SideTable::tableForPointer(oldObj);
    newTable = SideTable::tableForPointer(newObj);

    lock1 = &amp;newTable-&gt;slock;
<span class="preprocessor">#<span class="keyword">if</span> SIDE_TABLE_STRIPE &gt; 1</span>
    lock2 = &amp;oldTable-&gt;slock;
    <span class="keyword">if</span> (lock1 &gt; lock2) {
        <span class="keyword">spinlock_t</span> *temp = lock1;
        lock1 = lock2;
        lock2 = temp;
    }
    <span class="keyword">if</span> (lock1 != lock2) spinlock_lock(lock2);
<span class="preprocessor">#<span class="keyword">endif</span></span>
    spinlock_lock(lock1);

    <span class="keyword">if</span> (*location != oldObj) {
        spinlock_unlock(lock1);
<span class="preprocessor">#<span class="keyword">if</span> SIDE_TABLE_STRIPE &gt; 1</span>
        <span class="keyword">if</span> (lock1 != lock2) spinlock_unlock(lock2);
<span class="preprocessor">#<span class="keyword">endif</span></span>
        <span class="keyword">goto</span> retry;
    }

    weak_unregister_no_lock(&amp;oldTable-&gt;<span class="keyword">weak_t</span>able, oldObj, location);
    newObj = weak_register_no_lock(&amp;newTable-&gt;<span class="keyword">weak_t</span>able, newObj, location);
    <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span>

    <span class="comment">// Set is-weakly-referenced bit in refcount table.</span>
    <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) {
        newObj-&gt;setWeaklyReferenced_nolock();
    }

    <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span>
    *location = newObj;

    spinlock_unlock(lock1);
<span class="preprocessor">#<span class="keyword">if</span> SIDE_TABLE_STRIPE &gt; 1</span>
    <span class="keyword">if</span> (lock1 != lock2) spinlock_unlock(lock2);
<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="keyword">return</span> newObj;
}
</code></pre><h3 id="__weak（没有证实的功能）">__weak（没有证实的功能）</h3><p>这里是书上看到的，同时也是在源码中能找到的，但是我却没有证实的一个知识点，就是使用了附有__weak修饰符的变量，会自动注册到autoreleasePool中。</p>
<p>1.不管是从注释还是代码，都证实了在使用weak变量时为了保证对象没有释放，会添加到autoreleasePool中</p>
<pre><code>/** 
 * This loads <span class="keyword">the</span> object referenced <span class="keyword">by</span> a weak pointer <span class="keyword">and</span> returns <span class="keyword">it</span>, <span class="keyword">after</span>
 * retaining <span class="keyword">and</span> autoreleasing <span class="keyword">the</span> object <span class="keyword">to</span> ensure <span class="keyword">that</span> <span class="keyword">it</span> stays alive
 * long enough <span class="keyword">for</span> <span class="keyword">the</span> caller <span class="keyword">to</span> use <span class="keyword">it</span>. This function would be used
 * anywhere a __weak variable <span class="keyword">is</span> used <span class="keyword">in</span> an expression.
 * 
 * @param location The weak pointer address
 * 
 * @<span class="constant">return</span> The object pointed <span class="keyword">to</span> <span class="keyword">by</span> \e location, <span class="keyword">or</span> \c nil <span class="keyword">if</span> \e location <span class="keyword">is</span> \c nil.
 */
<span class="property">id</span>
objc_loadWeak(<span class="property">id</span> *location)
{
    <span class="keyword">if</span> (!*location) <span class="constant">return</span> nil;
<span class="command">    return</span> objc_autorelease(objc_loadWeakRetained(location));
}
</code></pre><p>2.这里weak_read_no_lock函数会retain这个对象，然后通过外部autorelease。</p>
<pre><code>id
objc_loadWeakRetained(id *location)
{
    id <span class="literal">result</span>;

    <span class="type">SideTable</span> *table;
    spinlock_t *lock;

 retry:
    <span class="literal">result</span> = *location;
    <span class="keyword">if</span> (!<span class="literal">result</span>) <span class="keyword">return</span> <span class="keyword">nil</span>;

    table = <span class="type">SideTable</span>::tableForPointer(<span class="literal">result</span>);
    lock = &amp;table-&gt;slock;

    spinlock_lock(lock);
    <span class="keyword">if</span> (*location != <span class="literal">result</span>) {
        spinlock_unlock(lock);
        goto retry;
    }

    <span class="literal">result</span> = weak_read_no_lock(&amp;table-&gt;weak_table, location);

    spinlock_unlock(lock);
    <span class="keyword">return</span> <span class="literal">result</span>;
}
</code></pre><p>由此可知正在使用的weak变量不会被释放，但是如果大量使用weak变量会造成autoreleasePool中得对象大量增加，所以我们需要找到一个平衡点。</p>
<h3 id="__autorelease">__autorelease</h3><p>这个修饰符很少用，等同于ARC无效时调用autorelease方法，一般可以配合@autorelease使用来达到减少瞬时内存峰值。</p>
<p>ARC到这里也告一段落了，回过头来发现在这一段学习的过程中有一种豁然开朗的感觉，以前可能大概知道一点内存管理，但总是有一些点不能理解，在学习的道路上又进了一步。下一次准备看一下GCD那一块的知识，也算是对这本书的一个交代。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>终于到最后一篇了，前面两篇几乎没有涉及到ARC，全是内存管理，这一次要好好研究一下ARC的底层实现，在看的过程中感觉以前学得C++忘的差不多了。这一篇主要讲ARC的<strong>strong,</strong>weak,__autorelease修饰符背后发生了什么。</p>
<h3 id="__strong">__strong</h3><p>找了很多资料，发现还是书上的解释比较靠谱，在strong类型对象超出作用域后会调用objc_release函数，当然在属性为strong的情况下赋值是会走这个方法objc_storeStrong，这个也是比较标准的setter方法的写法。<br>]]>
    
    </summary>
    
      <category term="ARC" scheme="http://blog.tracyone.com/tags/ARC/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出ARC(中)]]></title>
    <link href="http://blog.tracyone.com/2015/06/15/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAARC-%E4%B8%AD/"/>
    <id>http://blog.tracyone.com/2015/06/15/深入浅出ARC-中/</id>
    <published>2015-06-15T14:28:03.000Z</published>
    <updated>2015-06-16T01:49:57.000Z</updated>
    <content type="html"><![CDATA[<p>这篇主要探究一下dealloc额外做的两三事，autorelease的内幕，以及ARC的使用规则。本来不准备写dealloc和autorelease的，不过昨天在看源码的时候发现还是很有意思的，然后也是为了内存管理的完整性，就顺带着记录下来了。</p>
<h2 id="dealloc搞得鬼">dealloc搞得鬼</h2><p>上一次看到这里发现了一个objc_destructInstance函数的调用，这次主要就是探究下，这个函数做了什么。<br><a id="more"></a></p>
<pre><code><span class="function">id 
<span class="title">object_dispose</span><span class="params">(id obj)</span>
</span>{
    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;
    objc_destructInstance(obj);    
<span class="preprocessor">#<span class="keyword">if</span> SUPPORT_GC</span>
    <span class="keyword">if</span> (UseGC) {
        auto_zone_retain(gc_zone, obj); <span class="comment">// gc free expects rc==1</span>
    }
<span class="preprocessor">#<span class="keyword">endif</span></span>
    <span class="built_in">free</span>(obj);
    <span class="keyword">return</span> nil;
}
</code></pre><p>在这里大致做了三件事，调用c++ destructors，移除关联对象，清理散列表中得一些值。</p>
<pre><code>void <span class="built_in">*</span>objc_destructInstance<span class="params">(id obj)</span> 
{
    <span class="keyword">if</span> <span class="params">(obj)</span> {
        <span class="comment">// Read all of the flags at once for performance.</span>
        bool cxx = obj-&gt;hasCxxDtor<span class="params">()</span>;
        bool assoc = <span class="built_in">!</span>UseGC &amp;&amp; obj-&gt;hasAssociatedObjects<span class="params">()</span>;
        bool dealloc = <span class="built_in">!</span>UseGC;

        <span class="comment">// This order is important.</span>
        <span class="keyword">if</span> <span class="params">(cxx)</span> object_cxxDestruct<span class="params">(obj)</span>;
        <span class="keyword">if</span> <span class="params">(assoc)</span> _object_remove_assocations<span class="params">(obj)</span>;
        <span class="keyword">if</span> <span class="params">(dealloc)</span> obj-&gt;clearDeallocating<span class="params">()</span>;
    }
    return obj;
}
</code></pre><h3 id="destructors">destructors</h3><p>1.从名字上看能大概看出是一个c++的析构函数，如果不是isTaggedPointer则调用object_cxxDestructFromClass这个析构函数</p>
<pre><code>void object_cxxDestruct<span class="params">(id obj)</span>
{
    <span class="keyword">if</span> <span class="params">(!obj)</span> return;
    <span class="keyword">if</span> <span class="params">(obj-&gt;isTaggedPointer<span class="params">()</span>)</span> return;
    object_cxxDestructFromClass<span class="params">(obj, obj-&gt;ISA<span class="params">()</span>)</span>;
}
</code></pre><p>2.这里关键就是取到真正的析构函数，所以用了个函数指针，因为需要做一系列的判断，最后调用</p>
<pre><code>static void object_cxxDestructFromClass<span class="params">(id obj, Class cls)</span>
{
    void <span class="params">(*dtor)</span><span class="params">(id)</span>;

    <span class="comment">// Call cls's dtor first, then superclasses's dtors.</span>

    <span class="keyword">for</span> <span class="params">( ; cls; cls = cls-&gt;superclass)</span> {
        <span class="keyword">if</span> <span class="params">(!cls-&gt;hasCxxDtor<span class="params">()</span>)</span> return; 
        dtor = <span class="params">(void<span class="params">(*)</span><span class="params">(id)</span>)</span>
            lookupMethodInClassAndLoadCache<span class="params">(cls, SEL_cxx_destruct)</span>;
        <span class="keyword">if</span> <span class="params">(dtor != <span class="params">(void<span class="params">(*)</span><span class="params">(id)</span>)</span>_objc_msgForward_impcache)</span> {
            <span class="keyword">if</span> <span class="params">(PrintCxxCtors)</span> {
                _objc_inform<span class="params">(<span class="string">"CXX: calling C++ destructors for class %s"</span>, 
                             cls-&gt;nameForLogging<span class="params">()</span>)</span>;
            }
            <span class="params">(*dtor)</span><span class="params">(obj)</span>;
        }
    }
}
</code></pre><p>3.这个就是查找析构函数的函数，先从缓存表中找，再从方法列表中找，如果找到还要放到缓存表中，否则的话就调用方法转发，并且缓存起来。</p>
<pre><code><span class="type">IMP</span> lookupMethodInClassAndLoadCache(<span class="type">Class</span> cls, <span class="type">SEL</span> sel)
{
    <span class="type">Method</span> meth;
    <span class="type">IMP</span> imp;

    // fixme this <span class="keyword">is</span> incomplete - no resolver, +initialize, <span class="type">GC</span> - 
    // but it's only used <span class="keyword">for</span> .cxx_construct/destruct so we don't care
    assert(sel == <span class="type">SEL_cxx_construct</span>  ||  sel == <span class="type">SEL_cxx_destruct</span>);

    // <span class="type">Search</span> cache first.
    imp = cache_getImp(cls, sel);
    <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;

    // <span class="type">Cache</span> miss. <span class="type">Search</span> <span class="keyword">method</span> list.

    rwlock_read(&amp;runtimeLock);

    meth = getMethodNoSuper_nolock(cls, sel);

    <span class="keyword">if</span> (meth) {
        // <span class="type">Hit</span> <span class="keyword">in</span> <span class="keyword">method</span> list. <span class="type">Cache</span> it.
        cache_fill(cls, sel, meth-&gt;imp);
        rwlock_unlock_read(&amp;runtimeLock);
        <span class="keyword">return</span> meth-&gt;imp;
    } <span class="keyword">else</span> {
        // <span class="type">Miss</span> <span class="keyword">in</span> <span class="keyword">method</span> list. <span class="type">Cache</span> objc_msgForward.
        cache_fill(cls, sel, _objc_msgForward_impcache);
        rwlock_unlock_read(&amp;runtimeLock);
        <span class="keyword">return</span> _objc_msgForward_impcache;
    }
}
</code></pre><h3 id="关联对象">关联对象</h3><p>关联对象我记得之前有个大神讲过，看的有点迷糊，就自己翻了下源码，主要就一个函数，大致思路就是关联对象会存在一张映射表中，根据传入的object找到关联对象映射表，遍历映射表添加到vector中，然后最后清楚相关数据，最后的时候遍历vector，release关联对象。</p>
<pre><code>void _object_remove_assocations<span class="params">(id object)</span> {
    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;
    {
        AssociationsManager manager;
        AssociationsHashMap &amp;associations<span class="params">(manager.associations<span class="params">()</span>)</span>;
        <span class="keyword">if</span> <span class="params">(associations.size<span class="params">()</span> == <span class="number">0</span>)</span> return;
        disguised_ptr_t disguised_object = DISGUISE<span class="params">(object)</span>;
        AssociationsHashMap::iterator i = associations.find<span class="params">(disguised_object)</span>;
        <span class="keyword">if</span> <span class="params">(i != associations.end<span class="params">()</span>)</span> {
            <span class="comment">// copy all of the associations that need to be removed.</span>
            ObjectAssociationMap <span class="built_in">*</span>refs = i-&gt;second;
            <span class="keyword">for</span> <span class="params">(ObjectAssociationMap::iterator j = refs-&gt;begin<span class="params">()</span>, end = refs-&gt;end<span class="params">()</span>; j != end; ++j)</span> {
                elements.push_back<span class="params">(j-&gt;second)</span>;
            }
            <span class="comment">// remove the secondary table.</span>
            delete refs;
            associations.erase<span class="params">(i)</span>;
        }
    }
    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span>
    for_each<span class="params">(elements.begin<span class="params">()</span>, elements.end<span class="params">()</span>, ReleaseValue<span class="params">()</span>)</span>;
}
</code></pre><h3 id="clearDeallocating">clearDeallocating</h3><p>这里做的主要是清理weak变量，具体内容可以参考<a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/" target="_blank" rel="external">sunny大神的博客</a></p>
<pre><code><span class="tag">inline</span> <span class="tag">void</span> 
<span class="rule"><span class="attribute">objc_object</span>:<span class="value">:<span class="function">clearDeallocating</span>()
{
    <span class="function">sidetable_clearDeallocating</span>()</span></span>;
}
</code></pre><p>2.还是取散列表SideTable，遍历是否有weak引用，it-&gt;second &amp; SIDE_TABLE_WEAKLY_REFERENCED这里用到的就是前面所说的宏，作用就是标示是否有weak引用。如果有旧调用weak_clear_no_lock这个函数，这个函数中会遍历清除所有weak引用，这就是Objc不需要我们手动清理weak引用的关键点。</p>
<pre><code><span class="literal">void</span> 
objc_object<span class="tag">::sidetable_clearDeallocating</span>()
{
    SideTable <span class="subst">*</span>table <span class="subst">=</span> SideTable<span class="tag">::tableForPointer</span>(this);

    <span class="comment">// clear any weak table items</span>
    <span class="comment">// clear extra retain count and deallocating bit</span>
    <span class="comment">// (<span class="doctag"><span class="keyword">fixme</span></span> warn or abort if extra retain count == 0 ?)</span>
    spinlock_lock(<span class="subst">&amp;</span>table<span class="subst">-&gt;</span>slock);
    RefcountMap<span class="tag">::iterator</span> it <span class="subst">=</span> table<span class="subst">-&gt;</span>refcnts<span class="built_in">.</span>find(this);
    <span class="keyword">if</span> (it <span class="subst">!=</span> table<span class="subst">-&gt;</span>refcnts<span class="built_in">.</span>end()) {
        <span class="keyword">if</span> (it<span class="subst">-&gt;</span>second <span class="subst">&amp;</span> SIDE_TABLE_WEAKLY_REFERENCED) {
            weak_clear_no_lock(<span class="subst">&amp;</span>table<span class="subst">-&gt;</span>weak_table, (id)this);
        }
        table<span class="subst">-&gt;</span>refcnts<span class="built_in">.</span>erase(it);
    }
    spinlock_unlock(<span class="subst">&amp;</span>table<span class="subst">-&gt;</span>slock);
}
</code></pre><h2 id="autorelease的内幕">autorelease的内幕</h2><p>这个专题基本讲烂了，先上几篇我参考的优质博客<br><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">sunnyxx的《黑幕背后的Autorelease》</a><br><a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">雷纯锋的《Objective-C Autorelease Pool 的实现原理》</a></p>
<p>大神们已经讲的很详细了，不过为了内容的完整，还是硬着头皮自己去理一下逻辑，写一点不一样的东西，所以下面并不会去探究autoreleasePool实现原理，只看NSObject中autorelease函数的实现。</p>
<h3 id="autorelease函数做了什么">autorelease函数做了什么</h3><p>1.前面两步都是简单调用底层函数，最终调用的是rootAutorelease2函数</p>
<pre><code>- (<span class="keyword">id</span>)autorelease {
    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootAutorelease();
}

<span class="keyword">inline</span> <span class="keyword">id</span> 
objc_object::rootAutorelease()
{
    assert(!UseGC);

    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;
    <span class="keyword">if</span> (fastAutoreleaseForReturn((<span class="keyword">id</span>)<span class="keyword">this</span>)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;

    <span class="keyword">return</span> rootAutorelease2();
}
</code></pre><p>3.这一步会调用AutoreleasePoolPage的autorelease函数，关于AutoreleasePoolPage的实现可以看上面两位大神的讲解。</p>
<pre><code>__<span class="tag">attribute__</span>((<span class="tag">noinline</span>,<span class="tag">used</span>))
<span class="tag">id</span> 
<span class="rule"><span class="attribute">objc_object</span>:<span class="value">:<span class="function">rootAutorelease2</span>()
{
    <span class="function">assert</span>(!<span class="function">isTaggedPointer</span>())</span></span>;
    <span class="tag">return</span> <span class="rule"><span class="attribute">AutoreleasePoolPage</span>:<span class="value">:<span class="function">autorelease</span>((id)this)</span></span>;
}
</code></pre><p>4.这两步都是AutoreleasePoolPage的方法，主要就是判断当前page是否已满，如果没有就直接add，如果已经满了则会去重新new一个page，然后c设为当前页，并且添加进去，如果当前没有page，则会初始化第一个page然后添加。</p>
<pre><code>static inline id autorelease<span class="params">(id obj)</span>
    {
        assert<span class="params">(obj)</span>;
        assert<span class="params">(!obj-&gt;isTaggedPointer<span class="params">()</span>)</span>;
        id <span class="built_in">*</span>dest __unused = autoreleaseFast<span class="params">(obj)</span>;
        assert<span class="params">(!dest  ||  *dest == obj)</span>;
        return obj;
    }

static inline id <span class="built_in">*</span>autoreleaseFast<span class="params">(id obj)</span>
    {
        AutoreleasePoolPage <span class="built_in">*</span>page = hotPage<span class="params">()</span>;
        <span class="keyword">if</span> <span class="params">(page &amp;&amp; !page-&gt;full<span class="params">()</span>)</span> {
            return page-&gt;add<span class="params">(obj)</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(page)</span> {
            return autoreleaseFullPage<span class="params">(obj, page)</span>;
        } <span class="keyword">else</span> {
            return autoreleaseNoPage<span class="params">(obj)</span>;
        }
    }
</code></pre><h2 id="ARC使用原则">ARC使用原则</h2><h3 id="修饰符">修饰符</h3><p>其实这些东西都是老掉牙的内容了，我就简单说几点吧。这些不是关键，同样是为了内容完整性考虑。</p>
<ul>
<li>__strong 这个就是代表了强引用，在超出作用域的时候会release一下，大多数情况下strong已经能够保证内存管理正确了。</li>
<li>__weak 这个就是用来处理那些strong解决不了的情况，循环引用。只能在iOS5以上使用</li>
<li>__unsafe_unretain 这个就意味着不属于编译器的内存管理，如果指向的对象已经释放，野指针。</li>
<li>__autoreleasing 这个东西几乎很少用，因为大多数时间编译器知道哪些变量是需要autoreleasing。比如说在取得非自己持有的对象时，该对象自动被加入autoreleasing pool。再比如说访问id* 类型的变量。</li>
</ul>
<p>每个id类型的对象必须有一种修饰符，在ARC下，其中__strong是默认的修饰符。除了unsafe_unretain，其余的可以保证初始化为nil。</p>
<h3 id="规则">规则</h3><ol>
<li>不能使用retain/release/retainCount/autorelease。</li>
<li>不能使用NSAllocateObject/NSDeallocateObject。</li>
<li>必须遵守内存管理的命名规则。</li>
<li>不能显示的调用dealloc，比如[super dealloc]。</li>
<li>用@autorelease代替NSAutoreleasePool。</li>
<li>不能使用NSZone。</li>
<li>对象类型变量不能作为C语言结构体成员（可以用__unsafe_unretain修饰之后使用）</li>
<li>不能显示转换id和void*（可以通过<em>_bridge,\</em>_bridge_retained,__bridge_transfer）。</li>
</ol>
<p>这些都是书上有的，基本很全了。</p>
<h2 id="萌萌的小尾巴">萌萌的小尾巴</h2><p>到此ARC内存管理这一块讲了很多了，还剩下ARC具体实现了，这个放到下面一篇分析，ARC是由编译器来管理内存了，但实际上单纯靠编译器是实现不了的，还需要runtime来辅助。所以实际上ARC使用了Clang和Objc库来完成内存管理的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇主要探究一下dealloc额外做的两三事，autorelease的内幕，以及ARC的使用规则。本来不准备写dealloc和autorelease的，不过昨天在看源码的时候发现还是很有意思的，然后也是为了内存管理的完整性，就顺带着记录下来了。</p>
<h2 id="dealloc搞得鬼">dealloc搞得鬼</h2><p>上一次看到这里发现了一个objc_destructInstance函数的调用，这次主要就是探究下，这个函数做了什么。<br>]]>
    
    </summary>
    
      <category term="ARC" scheme="http://blog.tracyone.com/tags/ARC/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出ARC(上)]]></title>
    <link href="http://blog.tracyone.com/2015/06/14/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAARC-%E4%B8%8A/"/>
    <id>http://blog.tracyone.com/2015/06/14/深入浅出ARC-上/</id>
    <published>2015-06-14T15:14:12.000Z</published>
    <updated>2015-06-14T15:22:54.000Z</updated>
    <content type="html"><![CDATA[<p>最近和同事在讨论一个循环引用问题的时候，不经意间讨论到了内存管理的本质到底是什么，于是翻出《Objective-C高级编程》一看，但是发现上面有些问题，可能是比较旧了，苹果有了新的实现，所以拿出Objc源码研究了下，下面是自己研究的内容，如果理解有误，请定要联系我就找。</p>
<h3 id="内存管理">内存管理</h3><p>大家都知道，Objc是通过引用计数来管理内存的（Mac除外啊，毕竟处理器牛逼），主要就遵循以下几个原则：</p>
<ol>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要持有的对象，自己可以释放。</li>
<li>非自己持有的对象不能释放。</li>
</ol>
<p>其实这些就是对应了Objc中得alloc，retain等方法，这些是引用计数的思考方式，并不因是否ARC改变，那么接下来看一下一些底层实现。</p>
<a id="more"></a>
<h3 id="alloc">alloc</h3><p>通过苹果官网开源的Objc库，我们可以发现总共调用了如下几个方法，虽然很长，然而有一些我们是可以忽略的，逐步分析。</p>
<p>1.这个方法很简单就是调用了_objc_rootAlloc函数。</p>
<pre><code>+ (<span class="keyword">id</span>)alloc {
    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);
}
</code></pre><p>2.调用了callAlloc函数，这个函数有三个参数，其中第一个参数不能为空，这是一个最基础的alloc方法的实现。</p>
<pre><code>id
_objc_rootAlloc(<span class="class"><span class="keyword">Class</span> <span class="title">cls</span>)
</span>{
    <span class="keyword">return</span> callAlloc(cls, <span class="keyword">false</span><span class="comment">/*checkNil*/</span>, <span class="keyword">true</span><span class="comment">/*allocWithZone*/</span>);
}
</code></pre><p>3.这里调用的代码就变多了，其实大部分都不需要看，关键就在class_createInstance上，这也是真实地创建实例的方法。其他代码主要是</p>
<pre><code><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span>
callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)
{
    <span class="keyword">if</span> (checkNil &amp;&amp; !cls) <span class="keyword">return</span> <span class="literal">nil</span>;
\<span class="preprocessor">#if __OBJC2__</span>
    <span class="keyword">if</span> (! cls-&gt;ISA()-&gt;hasCustomAWZ()) {
        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span>
        <span class="comment">// <span class="doctag"><span class="keyword">fixme</span></span> store hasCustomAWZ in the non-meta class and </span>
        <span class="comment">// add it to canAllocFast's summary</span>
        <span class="keyword">if</span> (cls-&gt;canAllocFast()) {
            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span>
            <span class="keyword">bool</span> dtor = cls-&gt;hasCxxDtor();
            <span class="keyword">id</span> obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, cls-&gt;bits<span class="variable">.fastInstanceSize</span>());
            <span class="keyword">if</span> (!obj) <span class="keyword">return</span> callBadAllocHandler(cls);
            obj-&gt;initInstanceIsa(cls, dtor);
            <span class="keyword">return</span> obj;
        }
        <span class="keyword">else</span> {
            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span>
            <span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);
            <span class="keyword">if</span> (!obj) <span class="keyword">return</span> callBadAllocHandler(cls);
            <span class="keyword">return</span> obj;
        }
    }
<span class="preprocessor">#endif</span>

    <span class="comment">// No shortcuts available.</span>
    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:<span class="literal">nil</span>];
    <span class="keyword">return</span> [cls alloc];
}
</code></pre><p>4.这个函数则是调用了一个私有函数_class_createInstanceFromZone，从这里也能看出Objc其实已经不用zone了。</p>
<pre><code>id 
<span class="keyword">class</span><span class="number">_</span>createInstance(Class cls, size<span class="number">_</span>t extraBytes)
{
    <span class="keyword">return</span> <span class="number">_</span><span class="keyword">class</span><span class="number">_</span>createInstanceFromZone(cls, extraBytes, nil);
}
</code></pre><p>5.最终调用的其实是这一行代码obj = (id)calloc(1, size);到这里一个对象的初始化基本告一段落了，这中间跳过了很多，不过这次主要是探究一下和内存管理相关的，也无伤大雅。最后是用calloc分配了一个初始化为0的对象。</p>
<pre><code>static __attribute__<span class="params">(<span class="params">(always_inline)</span>)</span> 
id
_class_createInstanceFromZone<span class="params">(Class cls, size_t extraBytes, void *zone)</span>
{
    <span class="keyword">if</span> <span class="params">(!cls)</span> return nil;

    assert<span class="params">(cls-&gt;isRealized<span class="params">()</span>)</span>;

    <span class="comment">// Read class's info bits all at once for performance</span>
    bool hasCxxCtor = cls-&gt;hasCxxCtor<span class="params">()</span>;
    bool hasCxxDtor = cls-&gt;hasCxxDtor<span class="params">()</span>;
    bool fast = cls-&gt;canAllocIndexed<span class="params">()</span>;

    size_t size = cls-&gt;instanceSize<span class="params">(extraBytes)</span>;

    id obj;
    <span class="keyword">if</span> <span class="params">(!UseGC  &amp;&amp;  !zone  &amp;&amp;  fast)</span> {
        obj = <span class="params">(id)</span>calloc<span class="params">(<span class="number">1</span>, size)</span>;
        <span class="keyword">if</span> <span class="params">(!obj)</span> return nil;
        obj-&gt;initInstanceIsa<span class="params">(cls, hasCxxDtor)</span>;
    } 
    <span class="keyword">else</span> {
<span class="built_in">#</span><span class="keyword">if</span> SUPPORT_GC
        <span class="keyword">if</span> <span class="params">(UseGC)</span> {
            obj = <span class="params">(id)</span>auto_zone_allocate_object<span class="params">(gc_zone, size,
                                                AUTO_OBJECT_SCANNED, <span class="number">0</span>, <span class="number">1</span>)</span>;
        } <span class="keyword">else</span> 
<span class="built_in">#</span>endif
        <span class="keyword">if</span> <span class="params">(zone)</span> {
            obj = <span class="params">(id)</span>malloc_zone_calloc <span class="params">(<span class="params">(malloc_zone_t *)</span>zone, <span class="number">1</span>, size)</span>;
    } <span class="keyword">else</span> {
            obj = <span class="params">(id)</span>calloc<span class="params">(<span class="number">1</span>, size)</span>;
        }
        <span class="keyword">if</span> <span class="params">(!obj)</span> return nil;

        <span class="comment">// Use non-indexed isa on the assumption that they might be </span>
        <span class="comment">// doing something weird with the zone or RR.</span>
        obj-&gt;initIsa<span class="params">(cls)</span>;
    }

    <span class="keyword">if</span> <span class="params">(hasCxxCtor)</span> {
        obj = _objc_constructOrFree<span class="params">(obj, cls)</span>;
    }

    return obj;
}
</code></pre><h3 id="retianCount">retianCount</h3><p>前面可能大家会很奇怪，为什么没有看到初始化为1的retainCount呢？其实这和Objc的retainCount实现原理有关，下面上源码：</p>
<p>1.这个方法很简单就是调用了rootRetainCount这个函数</p>
<pre><code>- (NSUInteger)retainCount {
    <span class="keyword">return</span> <span class="function"><span class="params">((id)self)</span>-&gt;</span>rootRetainCount();
}
</code></pre><p>2.这里有一个是否isTaggedPointer的判断，相关内容可以查看唐巧的<a href="http://www.devtang.com/blog/2014/05/30/understand-tagged-pointer/" target="_blank" rel="external">这篇博客</a>。这个可以跳过，主要就是调用了sidetable_retainCount这个函数。</p>
<pre><code><span class="keyword">inline</span> <span class="keyword">uintptr_t</span> 
objc_object::rootRetainCount()
{
    assert(!UseGC);
    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)<span class="keyword">this</span>;
    <span class="keyword">return</span> sidetable_retainCount();
}
</code></pre><p>3.从名字上看这应该是一个和sidetable相关的函数，果然，里面使用了SideTable，从这里，我们大致可以看出Objc使用了类似散列表的结构来记录引用计数。并且在初始化的时候设为了一。不过在这里有一个很奇怪的点，为什么最后返回的refcnt_result是1加上it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT。这个也是苹果机智的地方，等下会介绍。</p>
<pre><code>uintptr_t
objc_object::sidetable_retainCount()
{
    <span class="type">SideTable</span> *table = <span class="type">SideTable</span>::tableForPointer(this);

    size_t refcnt_result = <span class="number">1</span>;

    spinlock_lock(&amp;table-&gt;slock);
    <span class="type">RefcountMap</span>::<span class="keyword">iterator</span> it = table-&gt;refcnts.find(this);
    <span class="keyword">if</span> (it != table-&gt;refcnts.<span class="keyword">end</span>()) {
        // this <span class="keyword">is</span> valid <span class="keyword">for</span> <span class="type">SIDE_TABLE_RC_PINNED</span> too
        refcnt_result += it-&gt;second &gt;&gt; <span class="type">SIDE_TABLE_RC_SHIFT</span>;
    }
    spinlock_unlock(&amp;table-&gt;slock);
    <span class="keyword">return</span> refcnt_result;
}
</code></pre><h3 id="retain">retain</h3><p>这个就比较简单了，总结下来其实就是找到散列表中得retainCount然后加1向左偏移SIDE_TABLE_RC_SHIFT的值，这里可能大家就知道为什么上面要有一个偏移值了。</p>
<p>1.还是简单地调用了Objc中得rootRetain函数</p>
<pre><code>- (id)retain {
    <span class="keyword">return</span> <span class="function"><span class="params">((id)self)</span>-&gt;</span>rootRetain();
}
</code></pre><p>2.同样是判断是否isTaggedPointer，然后调用sidetable_retain。</p>
<pre><code>inline id 
objc_object::rootRetain()
{
    <span class="keyword">assert</span>(!UseGC);
    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;
    <span class="function"><span class="keyword">return</span> <span class="title">sidetable_retain</span><span class="params">()</span></span>;
}
</code></pre><p>3.同样地取到SideTable，refcntStorage += SIDE_TABLE_RC_ONE，同样地加了一个偏移量。然后也能看出散列表的key是对象的指针。</p>
<pre><code>id
objc_object::sidetable_retain()
{
<span class="preprocessor">#<span class="keyword">if</span> SUPPORT_NONPOINTER_ISA</span>
    assert(!isa.indexed);
<span class="preprocessor">#<span class="keyword">endif</span></span>
    SideTable *table = SideTable::tableForPointer(<span class="keyword">this</span>);

    <span class="keyword">if</span> (<span class="keyword">spinlock_t</span>rylock(&amp;table-&gt;slock)) {
        <span class="keyword">size_t</span>&amp; refcntStorage = table-&gt;refcnts[<span class="keyword">this</span>];
        <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) {
            refcntStorage += SIDE_TABLE_RC_ONE;
        }
        spinlock_unlock(&amp;table-&gt;slock);
        <span class="keyword">return</span> (id)<span class="keyword">this</span>;
    }
    <span class="keyword">return</span> sidetable_retain_slow(table);
}
</code></pre><h3 id="release">release</h3><p>这里会解释SIDE_TABLE_RC_SHIFT这个偏移量存在的原因。前面两步和retain一样，不介绍了。</p>
<pre><code>- <span class="params">(oneway void)</span>release {
    <span class="params">(<span class="params">(id)</span>self)</span>-&gt;rootRelease<span class="params">()</span>;
}

inline bool 
objc_object::rootRelease<span class="params">()</span>
{
    assert<span class="params">(!UseGC)</span>;

    <span class="keyword">if</span> <span class="params">(isTaggedPointer<span class="params">()</span>)</span> return <span class="literal">false</span>;
    return sidetable_release<span class="params">(<span class="literal">true</span>)</span>;
}
</code></pre><p>3.主要看一下这里，其实加上SIDE_TABLE_RC_ONE这个便宜是为了空出SIDE_TABLE_DEALLOCATING这个标示，上定义大家就能懂了</p>
<p>// The order of these bits is important.</p>
<ul>
<li>#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</li>
<li>#define SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)  // MSB-ward of weak bit</li>
<li>#define SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)  // MSB-ward of deallocating bit</li>
<li>#define SIDE_TABLE_RC_SHIFT 2</li>
</ul>
<p>4.SIDE_TABLE_WEAKLY_REFERENCED是代表了弱引用，SIDE_TABLE_DEALLOCATING代表了需要释放的引用，SIDE_TABLE_RC_ONE这个则是正常的的偏移。值是和SIDE_TABLE_RC_SHIFT偏移一样的。<br>release比retain稍微复杂的地方就是他需要判断最终是否需要调用dealloc，所以多了很多判断和赋值，大概步骤就是1.先遍历变量是否存在，如果不存在就调用dealloc，2.如果存在再判断是否小于SIDE_TABLE_DEALLOCATING，如果成立同1，3.否则就减去一个SIDE_TABLE_RC_ONE4.最后看do_dealloc是否需要调用dealloc。</p>
<pre><code>bool 
objc_object::sidetable_release<span class="params">(bool performDealloc)</span>
{
\<span class="built_in">#</span><span class="keyword">if</span> SUPPORT_NONPOINTER_ISA
    assert<span class="params">(!isa.indexed)</span>;
\<span class="built_in">#</span>endif
    SideTable <span class="built_in">*</span>table = SideTable::tableForPointer<span class="params">(this)</span>;

    bool do_dealloc = <span class="literal">false</span>;

    <span class="keyword">if</span> <span class="params">(spinlock_trylock<span class="params">(&amp;table-&gt;slock)</span>)</span> {
        RefcountMap::iterator it = table-&gt;refcnts.find<span class="params">(this)</span>;
        <span class="keyword">if</span> <span class="params">(it == table-&gt;refcnts.end<span class="params">()</span>)</span> {
            do_dealloc = <span class="literal">true</span>;
            table-&gt;refcnts[this] = SIDE_TABLE_DEALLOCATING;
        } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(it-&gt;second &lt; SIDE_TABLE_DEALLOCATING)</span> {
            <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.</span>
            do_dealloc = <span class="literal">true</span>;
            it-&gt;second |= SIDE_TABLE_DEALLOCATING;
        } <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(! <span class="params">(it-&gt;second &amp; SIDE_TABLE_RC_<span class="literal">PI</span>NNED)</span>)</span> {
            it-&gt;second -= SIDE_TABLE_RC_ONE;
        }
        spinlock_unlock<span class="params">(&amp;table-&gt;slock)</span>;
        <span class="keyword">if</span> <span class="params">(do_dealloc  &amp;&amp;  performDealloc)</span> {
            <span class="params">(<span class="params">(void<span class="params">(*)</span><span class="params">(objc_object *, SEL)</span>)</span>objc_msgSend)</span><span class="params">(this, SEL_dealloc)</span>;
        }
        return do_dealloc;
    }

    return sidetable_release_slow<span class="params">(table, performDealloc)</span>;
}
</code></pre><h3 id="dealloc">dealloc</h3><p>这里其实有很多细节的，比如说在dealloc的时候会做哪些操作等，这个放到下一次讲，这里主要看的是dealloc实现原理，前面3步很简单，略过。</p>
<pre><code>- <span class="params">(void)</span>dealloc {
    _objc_rootDealloc<span class="params">(self)</span>;
}

void
_objc_rootDealloc<span class="params">(id obj)</span>
{
    assert<span class="params">(obj)</span>;

    obj-&gt;rootDealloc<span class="params">()</span>;
}

inline void
objc_object::rootDealloc<span class="params">()</span>
{
    <span class="keyword">if</span> <span class="params">(isTaggedPointer<span class="params">()</span>)</span> return;
    object_dispose<span class="params">(<span class="params">(id)</span>this)</span>;
}
</code></pre><p>4.这里能够清晰地看到在dealloc之前其实会调用一下objc_destructInstance，这里面做了很多操作，清理关联对象，weak引用等，最后free掉。</p>
<pre><code><span class="function">id 
<span class="title">object_dispose</span><span class="params">(id obj)</span>
</span>{
    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;
    objc_destructInstance(obj);

\<span class="preprocessor">#<span class="keyword">if</span> SUPPORT_GC</span>
    <span class="keyword">if</span> (UseGC) {
        auto_zone_retain(gc_zone, obj); <span class="comment">// gc free expects rc==1</span>
    }
\<span class="preprocessor">#<span class="keyword">endif</span></span>

    <span class="built_in">free</span>(obj);

    <span class="keyword">return</span> nil;
}
</code></pre><h3 id="ARC的引子">ARC的引子</h3><p>（这里，为ARC开个头，具体内容请看下回分析。）</p>
<p>顾名思义，ARC就是交给编译器来管理引用计数，而大家都知道Objc是通过引用计数来管理内存的，也就是说现在的内存管理已经不需要程序员来操心了（大多数情况下）</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近和同事在讨论一个循环引用问题的时候，不经意间讨论到了内存管理的本质到底是什么，于是翻出《Objective-C高级编程》一看，但是发现上面有些问题，可能是比较旧了，苹果有了新的实现，所以拿出Objc源码研究了下，下面是自己研究的内容，如果理解有误，请定要联系我就找。</p>
<h3 id="内存管理">内存管理</h3><p>大家都知道，Objc是通过引用计数来管理内存的（Mac除外啊，毕竟处理器牛逼），主要就遵循以下几个原则：</p>
<ol>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要持有的对象，自己可以释放。</li>
<li>非自己持有的对象不能释放。</li>
</ol>
<p>其实这些就是对应了Objc中得alloc，retain等方法，这些是引用计数的思考方式，并不因是否ARC改变，那么接下来看一下一些底层实现。</p>]]>
    
    </summary>
    
      <category term="ARC" scheme="http://blog.tracyone.com/tags/ARC/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Think in Block(下)]]></title>
    <link href="http://blog.tracyone.com/2015/06/10/Think-in-Block-%E4%B8%8B/"/>
    <id>http://blog.tracyone.com/2015/06/10/Think-in-Block-下/</id>
    <published>2015-06-10T13:28:22.000Z</published>
    <updated>2015-06-10T13:33:29.000Z</updated>
    <content type="html"><![CDATA[<p>这一篇主要浅析下Block和Objc的关系，更加偏向于实际应用。其实大多数时间我们是和Objc对象打交道，知道一点原理，能避免死的不明不白。</p>
<p>在这个过程中也会回答前面留下的坑- -，探究下来感觉，纸上得来终觉浅，以前也看过这本书，但是一直没有动手敲代码，浮于表面了。</p>
<h3 id="截获Objc对象">截获Objc对象</h3><p>先看下源程序，声明了一个Block对象，这次用到了copy，然后最后调用了三次，输出的结果是1，2，3。这一次转换后的代码非常多，不过抽离出来后也很简洁。</p>
<a id="more"></a>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)(<span class="keyword">id</span> obj);
<span class="keyword">int</span> main(){

    blk_t blk;
    {
        <span class="keyword">id</span> array = [[<span class="built_in">NSMutableArray</span> alloc] init];

        blk = [^(<span class="keyword">id</span> obj){
            [array addObject:obj];

            <span class="built_in">NSLog</span>(<span class="string">@"array count = %ld"</span>, [array count]);
        } <span class="keyword">copy</span>];
    }

    blk([[<span class="built_in">NSObject</span> alloc] init]);
    blk([[<span class="built_in">NSObject</span> alloc] init]);
    blk([[<span class="built_in">NSObject</span> alloc] init]);
}
</code></pre><p>在这里，我们能够看出来，Block对于Objc对象的截获是通过指针，并且和外部修饰符一致，也就是说外部是strong，内部也是strong，然后c结构体中并不能很好地管理内存，所以其实是通过运行时来掌控的，也就是后面会看到的copy和dispose函数的作用。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(*blk_t)(<span class="keyword">id</span> obj);
<span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  <span class="keyword">id</span> array;
  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">id</span> _array, <span class="keyword">int</span> flags=<span class="number">0</span>) : array(_array) {
    impl<span class="variable">.isa</span> = &amp;_<span class="built_in">NSConcreteStackBlock</span>;
    impl<span class="variable">.Flags</span> = flags;
    impl<span class="variable">.FuncPtr</span> = fp;
    Desc = desc;
  }
};

<span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself, <span class="keyword">id</span> obj) {
      <span class="keyword">id</span> array = __cself-&gt;array; <span class="comment">// bound by copy</span>

      ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)array, sel_registerName(<span class="string">"addObject:"</span>), (<span class="keyword">id</span>)obj);

      <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__<span class="built_in">NSConstantStringImpl__var_folders_hv_3dth3by12sg3t1g37hq5plkw0000gn_T_main_18c6fa_mi_0</span>, ((<span class="built_in">NSUInteger</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)array, sel_registerName(<span class="string">"count"</span>)));
}
</code></pre><ol>
<li>在把Block对象拷贝到堆上的时候copy函数会被调用，而在Block从堆上释放的时候dispose会被调用。</li>
<li>在调用copy函数的时候_Block_object_assign将外部对象赋值给Block结构体的成员变量，并持有它。</li>
<li>在调用dispose函数的时候_Block_object_dispose将释放Block结构体的成员变量。</li>
</ol>
<p>有了这些隐藏在背后的操作后，通过使用strong类型的局部对象，Block截获后能够在超出其变量作用域而存在。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) {
    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;<span class="built_in">array</span>, (<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);
}

<span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) {
    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;<span class="built_in">array</span>, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);
}

<span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 {
  <span class="keyword">size_t</span> reserved;
  <span class="keyword">size_t</span> Block_size;
  <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);
  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);
} __main_block_desc_0_DATA = { <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
</code></pre><p>其实回过头去看一下截获__block变量的时候也生成了两个类似的函数，唯一的区别是BLOCK_FIELD_IS_OBJECT和BLOCK_FIELD_IS_BYREF，这只是用来标示这是一个对象，还是一个变量。</p>
<pre><code>int main<span class="params">()</span>{

    blk_t blk;
    {
        id array = <span class="params">(<span class="params">(NSMutableArray *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(NSMutableArray *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSMutableArray"</span>)</span>, sel_registerName<span class="params">(<span class="string">"alloc"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"init"</span>)</span>)</span>;

        blk = <span class="params">(blk_t)</span><span class="params">(<span class="params">(id <span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>&amp;__main_block_impl_0<span class="params">(<span class="params">(void *)</span>__main_block_func_0, &amp;__main_block_desc_0_DATA, array, <span class="number">570425344</span>)</span>, sel_registerName<span class="params">(<span class="string">"copy"</span>)</span>)</span>;
    }


    <span class="params">(<span class="params">(void <span class="params">(*)</span><span class="params">(__block_impl *, id)</span>)</span><span class="params">(<span class="params">(__block_impl *)</span>blk)</span>-&gt;FuncPtr)</span><span class="params">(<span class="params">(__block_impl *)</span>blk, <span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"alloc"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"init"</span>)</span>)</span>)</span>;
    <span class="params">(<span class="params">(void <span class="params">(*)</span><span class="params">(__block_impl *, id)</span>)</span><span class="params">(<span class="params">(__block_impl *)</span>blk)</span>-&gt;FuncPtr)</span><span class="params">(<span class="params">(__block_impl *)</span>blk, <span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"alloc"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"init"</span>)</span>)</span>)</span>;
    <span class="params">(<span class="params">(void <span class="params">(*)</span><span class="params">(__block_impl *, id)</span>)</span><span class="params">(<span class="params">(__block_impl *)</span>blk)</span>-&gt;FuncPtr)</span><span class="params">(<span class="params">(__block_impl *)</span>blk, <span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span><span class="params">(<span class="params">(NSObject *<span class="params">(*)</span><span class="params">(id, SEL)</span>)</span><span class="params">(void *)</span>objc_msgSend)</span><span class="params">(<span class="params">(id)</span>objc_getClass<span class="params">(<span class="string">"NSObject"</span>)</span>, sel_registerName<span class="params">(<span class="string">"alloc"</span>)</span>)</span>, sel_registerName<span class="params">(<span class="string">"init"</span>)</span>)</span>)</span>;

}
</code></pre><p>tips：上面这些代码其实和书上的有一定的区别，也即是前面说得，我们的技术在提升，当然苹果没有理由不提升，不管是编译器还是底层实现。其实这里加不加copy都一样，应该是最近ARC的机制有了一点改变，这个后面会出一篇Blog详解。</p>
<h3 id="循环引用">循环引用</h3><p>由于上边所示那样的内存管理机制，当我们截获strong类型的对象时，很容易出现循环引用，但是也不用担心，没必要无时不刻的用一个__weak来避免，盲目地使用只会暴露出并没有深入地理解。</p>
<p>这里给出三种方法来避免循环引用：</p>
<ol>
<li>__weak 修饰符</li>
</ol>
<p>通过weak肯定能解除循环引用，但也有缺点，有时候我们会在内部使用strong来保证执行block的时候外部变量不会释放，但这也不能避免在block执行前已经释放了这种情形。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)();
<span class="class"><span class="keyword">@interface</span> <span class="title">Block</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)blk_t blk;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">Block</span></span>
- (instancetype)init{
    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {
        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;
        <span class="keyword">self</span><span class="variable">.blk</span> = ^{
            <span class="built_in">NSLog</span>(<span class="string">@"test%@"</span>, weakSelf<span class="variable">.array</span>);
        };
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
<span class="keyword">@end</span>
</code></pre><ol>
<li>__block修饰符+nil操作</li>
</ol>
<p>这种情况则也能避免循环引用，但是有个前提，这个Block必须在某个地方执行，否则还是不能打破循环引用环，但是这么做的好处还是很多的，首先可以延长生命周期，其次在执行Block的时候可以决定是否是将nil赋予，还是给另一个值。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)();
<span class="class"><span class="keyword">@interface</span> <span class="title">Block</span> ()</span>
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *array;
<span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>)blk_t blk;
<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">Block</span></span>
- (instancetype)init{
    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {

        __block <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;

        <span class="keyword">self</span><span class="variable">.blk</span> = ^{
            <span class="built_in">NSLog</span>(<span class="string">@"test%@"</span>, weakSelf<span class="variable">.array</span>);
            weakSelf = <span class="literal">nil</span>;
        };
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}
<span class="keyword">@end</span>
</code></pre><ol>
<li><strong>unsafe</strong>unretain修饰符</li>
</ol>
<p>这其实只是用在一些weak不支持的场合，现在几乎不怎么用了。</p>
<p>三者各有优缺点，<strong>weak不能够延长生命周期，</strong>block修饰符，如果最后没有执行，导致赋值nil不能够执行则还是会循环引用，<strong>unsafe</strong>unretain和weak相似，但是有可能会出现野指针的情况。</p>
<h3 id="MRC下地Block">MRC下地Block</h3><ul>
<li>在mrc下需要手动的调用copy和release，只要是copy到堆上了，则可以使用retain来持有，否则retain并没有效果。</li>
<li>在C语言中也支持，使用的是Block_copy和Block_release函数。</li>
<li>在ARC无效的时候我们只需要使用<strong>block就能避免循环引用了，这是因为，在mrc下</strong>block对象不会被retain。</li>
</ul>
<h3 id="结束语">结束语</h3><p>关于Block的探究也差不多了，接下来就是实战中去体会了，不过在探究的过程中发现，是时候去深入地理解一下Objc的内存管理机制，同时也发现在这本书中的ARC讲解已经有点过时了，有些和真实地情况有出入。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这一篇主要浅析下Block和Objc的关系，更加偏向于实际应用。其实大多数时间我们是和Objc对象打交道，知道一点原理，能避免死的不明不白。</p>
<p>在这个过程中也会回答前面留下的坑- -，探究下来感觉，纸上得来终觉浅，以前也看过这本书，但是一直没有动手敲代码，浮于表面了。</p>
<h3 id="截获Objc对象">截获Objc对象</h3><p>先看下源程序，声明了一个Block对象，这次用到了copy，然后最后调用了三次，输出的结果是1，2，3。这一次转换后的代码非常多，不过抽离出来后也很简洁。</p>]]>
    
    </summary>
    
      <category term="block" scheme="http://blog.tracyone.com/tags/block/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Think in Block(上)]]></title>
    <link href="http://blog.tracyone.com/2015/06/07/Think-in-Block-%E4%B8%8A/"/>
    <id>http://blog.tracyone.com/2015/06/07/Think-in-Block-上/</id>
    <published>2015-06-07T13:14:38.000Z</published>
    <updated>2015-06-09T13:22:05.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Block_简介">Block 简介</h2><p>这不是一篇介绍如何使用Block的文章，主要想要探究一下系统背后Block发生了什么，主要参考的是《Objective-C高级编程》这本书，不过这本书本身也有些年代了，苹果实现的机制也有了一些改变。实践出真知，不清楚的地方自己动手试一下，会有意外地收获。</p>
<h3 id="Block是什么">Block是什么</h3><p>苹果官网说法：<br>A block is an anonymous inline collection of code, and sometimes also called a “closure”.</p>
<p>通俗的讲：<br>闭包就是能够读取其它函数内部变量的匿名函数</p>
<p>与普通函数的区别：<br>普通函数能使用局部变量，参数，静态变量，静态全局，全局变量，并且有自己的函数名。<br>block除了能使用这些外还能使用其他函数内的变量，而且没有函数名。</p>
<a id="more"></a>
<h3 id="BLock的用法和功能">BLock的用法和功能</h3><h5 id="语法">语法</h5><p>void (^)(void){<br>};<br>与C语言函数相比没有函数名，带有^；可省略很多部分。</p>
<h5 id="变量">变量</h5><p>void (^var)(void)；<br>与C语言函数指针相比只是把*改成了^,Block变量和普通变量作用完全相同。</p>
<ol>
<li>通过typedef可以简化声明</li>
<li>调用和C语言函数调用一样，变量名+小括号</li>
</ol>
<h5 id="截获变量">截获变量</h5><ol>
<li>Block可以使用在它之前声明的局部变量，因此在执行Block时，即使已经改变了值，也不影响Block中截获的值。</li>
<li>一般情况，Block只能保存声明时的瞬间值，保存后就不能修改了；如果需要改变则要附加__block.</li>
<li>如果截获的是oc对象，使用是没有问题的，但是如果要重新赋值，则也必须加__block。</li>
</ol>
<h3 id="Block的实现">Block的实现</h3><h5 id="Block的本质">Block的本质</h5><p>先看下源代码：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{

    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
        <span class="built_in">printf</span>(<span class="string">"Block\n"</span>);
    };

    blk();
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>很简单，简单地定义一个Block，赋给blk对象，然后调用这个Block，那么这段代码经过编译器编译过后，发生了什么呢？我们用Clang 命令 -rewirte-objc转换成c++看下编译器搞得什么鬼！</p>
<p>首先是这一段，这段代码是编译器插入的代码，主要作用就是声明了一个结构体，这可以看成是我们的<code>Block类</code>的数据部分</p>
<pre><code><span class="preprocessor">#ifndef BLOCK_IMPL</span>
<span class="preprocessor">#define BLOCK_IMPL</span>
<span class="keyword">struct</span> __block_impl {
  <span class="keyword">void</span> *isa;
  <span class="keyword">int</span> Flags;
  <span class="keyword">int</span> Reserved;
  <span class="keyword">void</span> *FuncPtr;
};
</code></pre><p>这一段则是系统给我们声明的真正的<code>Block类</code>，其中包括了数据部分和一些描述性内容，以及一个初始化函数。</p>
<pre><code><span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl <span class="keyword">impl</span>;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) {
    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;
    <span class="keyword">impl</span>.Flags = flags;
    <span class="keyword">impl</span>.FuncPtr = fp;
    Desc = desc;
  }
};
</code></pre><p>这一段则是赋值给Block变量中的那个函数的声明，其中会把self传入，这个很多语言都会这么处理，在内部使用self的时候能够找到真实地那个对象。</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) {

        <span class="built_in">printf</span>(<span class="string">"Block\n"</span>);
    }
</code></pre><p>这一段则是前面所说的描述性的内容，主要就是Block对象的大小，因为这个例子比较简单，复杂的情况这里还会生成其他的一些函数，后面会讲到。<br>    static struct <strong>main_block_desc_0 {<br>      size_t reserved;<br>      size_t Block_size;<br>    } </strong>main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};</p>
<p>最后则是这一段我们写得main函数的代码，通过调用__main_block_impl_0函数来初始化一个Block对象，最后调用也就是简单地用c语言函数指针的方式调用。<br>    int main() {</p>
<pre><code>    void <span class="comment">(*blk)(void) = (void (*)</span>())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA);

    ((void <span class="comment">(*)(__block_impl *)</span>)((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
    return <span class="number">0</span>;
}
</code></pre><p>从isa的存在我们也大概能够看出来Block其实就是Objc的对象，只不过这是一个为了性能考虑而可能在栈上生成的一个对象。</p>
<h5 id="如何截获自动变量">如何截获自动变量</h5><p>这一次尝试一下使用Block来截获外部变量，看一下，Block如何能够使用外部变量，原函数：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span>{

    <span class="keyword">int</span> dmy = <span class="number">256</span>;
    <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">10</span>;
    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"var = %d\n"</span>;

    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
        printf(fmt, <span class="keyword">var</span>);
    };

    <span class="keyword">var</span> = <span class="number">2</span>;
    fmt = <span class="string">"Real var = %d\n"</span>;

    blk();
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>重写以后发现，其实没有多大改变，只是多了一些内容：</p>
<ul>
<li>__main_block_impl_0中多了一个指针fmt，和int类型的变量，其实也很容易理解，就是用来存放外部变量的。</li>
<li>__main_block_impl_0初始化的时候会同时对成员变量赋值。</li>
<li>__main_block_func_0中会在开始的地方帮你声明两个同名的变量，赋值的值则是从传入的self通过指针取值。</li>
</ul>
<p>那么其实从这些我们也不难看出，Block其实只截获了内部用到对象，以及为什么Block中普通截获的值不能改变，当然不能改写只是编译器检查，因为改了也没用。</p>
<pre><code><span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;
  <span class="keyword">int</span> <span class="keyword">var</span>;
  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _var, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), <span class="keyword">var</span>(_var) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
<span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) {
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// bound by copy</span>
  <span class="keyword">int</span> <span class="keyword">var</span> = __cself-&gt;<span class="keyword">var</span>; <span class="comment">// bound by copy</span>

        printf(fmt, <span class="keyword">var</span>);
    }

<span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)};
<span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span>{

    <span class="keyword">int</span> dmy = <span class="number">256</span>;
    <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">10</span>;
    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"var = %d\n"</span>;

    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, <span class="keyword">var</span>);

    <span class="keyword">var</span> = <span class="number">2</span>;
    fmt = <span class="string">"Real var = %d\n"</span>;

    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><h3 id="__block的作用">__block的作用</h3><p>首先来看下，有哪些变量是就算不在函数内声明，函数中也能使用和改变值的：静态变量，静态全局，全局变量。那这些变量是通过什么方式来实现的呢？<br>对于全部变量来说，其实本身它的作用域就已经包括了函数所在区域，能使用并不奇怪，普通的静态变量其实是通过指针来做到的。<br>那其实也不难推出，__block基本上来说也是通过指针（因为这也是最简单地一种方法）。<br>废话不多说，上代码：</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>) </span>{

    __block <span class="keyword">int</span> <span class="keyword">var</span> = <span class="number">10</span>;
    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
        <span class="keyword">var</span> = <span class="number">1</span>;
    };
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>经过重写后发现，增加了狂多代码，不过不用慌，都是可读性很强的代码，慢慢分析。</p>
<p>这一段就是<strong>block说明符修饰过后的变量最终声明的结构体，其中 </strong>forwarding很重要（这个是不同存储区域能访问到同一个变量的关键）</p>
<pre><code><span class="keyword">struct</span> __Block_byref_var_0 {
  <span class="keyword">void</span> *__isa;
__Block_byref_var_0 *__forwarding;
 <span class="keyword">int</span> __flags;
 <span class="keyword">int</span> __size;
 <span class="keyword">int</span> <span class="keyword">var</span>;
};
</code></pre><p>在这里大概也看出了一点端倪，其实传给var指针的是_var-&gt;<strong>forwarding，后面会给出 </strong>forwarding指向的是谁。</p>
<pre><code>struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* <span class="type">Desc</span>;
  __Block_byref_var_0 *<span class="keyword">var</span>; // by <span class="keyword">ref</span>
  __main_block_impl_0(<span class="type">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_var_0 *_var, <span class="type">int</span> flags=<span class="number">0</span>) : <span class="keyword">var</span>(_var-&gt;__forwarding) {
    impl.isa = &amp;_NSConcreteStackBlock;
    impl.<span class="type">Flags</span> = flags;
    impl.<span class="type">FuncPtr</span> = fp;
    <span class="type">Desc</span> = desc;
  }
};
</code></pre><p>看到这，基本就知道为什么用__block修饰的变量，在Block中也能改变了，因为内部声明时是用了指针嘛。</p>
<pre><code><span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_var_0 *<span class="keyword">var</span> = __cself-&gt;<span class="keyword">var</span>; // bound by <span class="keyword">ref</span>

        (<span class="keyword">var</span>-&gt;__forwarding-&gt;<span class="keyword">var</span>) = <span class="number">1</span>;
    }
</code></pre><p>这里的copy，和dispose先略过，在后续的Objc对象那部分会详解。<br>    static void <strong>main_block_copy_0(struct </strong>main_block_impl_0<em>dst, struct __main_block_impl_0</em>src) {_Block_object_assign((void<em>)&amp;dst-&gt;var, (void</em>)src-&gt;var, 8/<em>BLOCK_FIELD_IS_BYREF</em>/);}</p>
<pre><code><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) {_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;var, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);}

<span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 {
  <span class="keyword">size_t</span> reserved;
  <span class="keyword">size_t</span> Block_size;
  <span class="keyword">void</span> (*copy)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);
  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);
} __main_block_desc_0_DATA = { <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};
</code></pre><p>通过这一段，可以看出其实var已经不是简单地Int类型了，变得老长老长了，编译器总是在默默中给我们加了点料。同时也知道了__forwarding指向的是var自身。<br>    int main() {</p>
<pre><code>    __attribute__<span class="params">(<span class="params">(__blocks__<span class="params">(byref)</span>)</span>)</span> __Block_byref_var_0 var = {<span class="params">(void*)</span><span class="number">0</span>,<span class="params">(__Block_byref_var_0 *)</span>&amp;var, <span class="number">0</span>, sizeof<span class="params">(__Block_byref_var_0)</span>, <span class="number">10</span>};
    void <span class="params">(*blk)</span><span class="params">(void)</span> = <span class="params">(void <span class="params">(*)</span><span class="params">()</span>)</span>&amp;__main_block_impl_0<span class="params">(<span class="params">(void *)</span>__main_block_func_0, &amp;__main_block_desc_0_DATA, <span class="params">(__Block_byref_var_0 *)</span>&amp;var, <span class="number">570425344</span>)</span>;
    return <span class="number">0</span>;
}
</code></pre><h3 id="Block,__block存储域">Block,__block存储域</h3><p>Q:Block超出变量作用域可存在？</p>
<p>A:</p>
<ol>
<li>配置在全局变量中得Block，在变量作用域之外也可以通过指针安全的使用</li>
<li>在栈上得Block则是通过复制到堆上来解决的</li>
<li>而<strong>block变量用 </strong>forward可以实现无论配置在哪都可以正确地访问 __block变量</li>
<li>在ARC下，大多数情况下编译器会恰当的判断，自动将Block从栈上复制到堆上。（autorelease）</li>
</ol>
<p>补充：</p>
<ul>
<li>自动copy：Block作为函数的返回值时</li>
<li>手动copy：向方法或函数的参数中传递Block（但是可以在函数中适当地copy就不必在传递前copy）（例如GCD，Animation等）</li>
</ul>
<p>Q:调用Copy时不同的Block对象究竟发生了什么：</p>
<ol>
<li>_NSConcreteStackBlock            ：从栈复制到堆</li>
<li>_NSConcreteGlobalBlock            ：什么也不做</li>
<li>_NSConcreteMallocBlock            ：引用计数增加</li>
</ol>
<p>Q:调用Copy时不同的__block对象究竟发生了什么：</p>
<ol>
<li>栈            ：从栈复制到堆，并且被Block持有</li>
<li>堆            ：被Block持有</li>
</ol>
<h3 id="新的开始">新的开始</h3><p>这一篇，主要把Block变量和__block变量分析了一下，对于Objc中得对象，Block如何处理放到下一篇详细的讲述，同时下一篇也会详细的讲解一下避免Block循环引用的N种姿势。以及之前没有讲得copy和dispose是干嘛的，顺带着还会说一下mrc下地Block。</p>
<p>当然本人才疏学浅，上面只是个人的一些理解，可能会有偏差，如果有误，欢迎吐槽纠正。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Block_简介">Block 简介</h2><p>这不是一篇介绍如何使用Block的文章，主要想要探究一下系统背后Block发生了什么，主要参考的是《Objective-C高级编程》这本书，不过这本书本身也有些年代了，苹果实现的机制也有了一些改变。实践出真知，不清楚的地方自己动手试一下，会有意外地收获。</p>
<h3 id="Block是什么">Block是什么</h3><p>苹果官网说法：<br>A block is an anonymous inline collection of code, and sometimes also called a “closure”.</p>
<p>通俗的讲：<br>闭包就是能够读取其它函数内部变量的匿名函数</p>
<p>与普通函数的区别：<br>普通函数能使用局部变量，参数，静态变量，静态全局，全局变量，并且有自己的函数名。<br>block除了能使用这些外还能使用其他函数内的变量，而且没有函数名。</p>]]>
    
    </summary>
    
      <category term="block" scheme="http://blog.tracyone.com/tags/block/"/>
    
      <category term="iOS" scheme="http://blog.tracyone.com/categories/iOS/"/>
    
  </entry>
  
</feed>